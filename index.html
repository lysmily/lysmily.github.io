<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="燎原的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="燎原的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="燎原的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>燎原的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">燎原的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/twelveth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/twelveth/" itemprop="url">小圆第十二天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T17:49:51+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>字符串是编程时,用到最多的数据结构,当我们判断一个数据是否是合法的Email地址时,虽然我们可以编程提前<font color="red"><code>@</code></font>前后的子串,然后判断是否是单词和域名,这样做非常麻烦,并且代码不能复用,因此正则表达式就出现了.  </p>
<p>我们判断一个字符串是否是合法的Email的方法是:</p>
<ol>
<li>创建一个匹配Email的正则表达式</li>
<li>用该正则表达式去匹配用户的输入来判断是否合法.</li>
</ol>
<p>在正则表达式中如果直接给出字符就是精确匹配,用<font color="red"><code>\d</code></font>可以匹配一个数字,<font color="red"><code>\w</code></font>可以匹配一个字母或数字,<font color="red"><code>.</code></font>可以匹配任意字符,<font color="red"><code>*</code></font>表示任意个字符,<font color="red"><code>+</code></font>表示至少一个字符,<font color="red"><code>?</code></font>表示0个或者1个字符,<font color="red"><code>{n}</code></font>表示n个字符,<font color="red"><code>{n,m}</code></font>表示n-m个字符.让我们看一个栗子:<font color="red"><code>\d{3}\s+\d{3,8}</code></font>.</p>
<p>我们来解读一下:</p>
<ol>
<li><font color="red"><code>\d{3}</code></font>表示匹配3个数字,例如010</li>
<li><font color="red"><code>\s</code></font>可以匹配一个空格(也包括Tab等空白符),所以<font color="red"><code>\s+</code></font>表示至少有一个空格.</li>
<li><font color="red"><code>\d{3,8}</code></font>表示3-8个数字,例如<font color="red"><code>123456</code></font>.</li>
</ol>
<p>综合起来上面的正则表达式可以匹配任意一个空格隔开的带区号的电话号码.</p>
<p>如果是<font color="red"><code>010-123456</code></font>呢?我们这么写<font color="red"><code>\d{3}\-\d{3,8}</code></font>,但是仍然无法匹配<font color="red"><code>010 - 123456</code></font>这样带有空格的.所以还要改进.</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>为了更精确的匹配,我们可以使用<font color="red"><code>[]</code></font>来表示范围,比如:</p>
<ul>
<li><font color="red"><code>[0-9a-zA-Z\_]</code></font>可以匹配一个数字,字母,下划线.</li>
<li><font color="red"><code>[0-9a-zA-Z\_]+</code></font>可以匹配至少一个由字母,数字,下划线组成的字符串如:’a456’,’5_a’</li>
<li><font color="red"><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code></font>可以匹配由字母数字下划线开头,后接任意个字母,数字,下划线组成的字符串.</li>
<li><font color="red"><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code></font>可以匹配由字母数字下划线开头,后接有限个(最多19)字母,数字,下划线组成的字符串.</li>
</ul>
<p><font color="red"><code>A|B</code></font>可以匹配A或B,例如:<font color="red"><code>(P|p)</code></font>,可以匹配’Python’和’python’</p>
<p><font color="red"><code>^</code></font>^表示行的开头，<font color="red"><code>^\d</code></font>表示必须以数字开头。<font color="red"><code>$</code></font>表示行的结束，<font color="red"><code>\d$</code></font>表示必须以数字结束。</p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>Python提供<font color="red"><code>re</code></font>模块,包含所以正则表达式的功能,由于python的字符串本身也用<font color="red"><code>\</code></font>转义,因此强烈建议使用Python的前缀<font color="red"><code>r</code></font>,就不用考虑转义的问题了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = r&apos;ABC\\-001&apos;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&gt;&gt;&gt; &apos;ABC\\\\-001&apos;</span><br></pre></td></tr></table></figure></p>
<p>那就让我们试试re模块如何使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010 12345&apos;)</span><br></pre></td></tr></table></figure></p>
<p>也就是说<font color="red"><code>match()</code></font>方法判断如果成功就返回一个March对象,如果失败就返回None.</p>
<h2 id="节分字符串"><a href="#节分字符串" class="headerlink" title="节分字符串"></a>节分字符串</h2><p>这次我们终于说到<font color="red"><code>split</code></font>函数,让我们看看正常的切分代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;a b   c&apos;.split(&apos; &apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面不能识别连续的空格,那我们加上正则表达式试试看:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b   c&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"># 再试试加上逗号</span><br><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,]+&apos;, &apos;a,b, c  d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单的匹配之外,正则表达式还提供了提取子串的功能,用<font color="red"><code>()</code></font>表示的就是要提取的分组.比如:<code>^(\d{3})-(\d{3,8})$</code>分别定义了两个分组,可以直接从匹配的字符里面提取区号和本地号码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; m.group(0)</span><br><span class="line">&apos;010-12345&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(1)</span><br><span class="line">&apos;010&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(2)</span><br><span class="line">&apos;12345&apos;</span><br></pre></td></tr></table></figure></p>
<p>注意上面的<font color="red"><code>group(0)</code></font>永远是原始字符,<font color="red"><code>group(1)</code></font>,<font color="red"><code>group(2)</code></font>…表示第1,2…个子串.让我们看一个凶残的栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = &apos;19:05:30&apos;</span><br><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&apos;, t)</span><br><span class="line">&gt;&gt;&gt; m.groups()</span><br><span class="line">(&apos;19&apos;, &apos;05&apos;, &apos;30&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>最后需要了解的是正则匹配默认是贪婪匹配,也就是匹配尽可能多的字符.看看下面你就明白了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>由于采用贪婪模式,<font color="red"><code>\d+</code></font>直接把后面的0全部匹配了,后面的<font color="red"><code>0*</code></font>只能匹配空字符串.如果我们想采用非贪婪模式,加上<font color="red"><code>?</code></font>就可以了.我们看看结果是啥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<p>如果一个正则表达式要使用很多次,我们可以考虑把它预编译,这样重复使用的时候就不用编译这个步骤了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 编译:</span><br><span class="line">&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line"># 使用：</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="两个小练习"><a href="#两个小练习" class="headerlink" title="两个小练习"></a>两个小练习</h2><p>请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：</p>
<ul>
<li><a href="mailto:someone@gmail.com" target="_blank" rel="noopener">someone@gmail.com</a></li>
<li><a href="mailto:bill.gates@microsoft.com" target="_blank" rel="noopener">bill.gates@microsoft.com</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">def is_valid_email(addr):</span><br><span class="line">    if re.match(r&apos;^[a-zA-Z.]&#123;2,15&#125;@[a-zA-Z]&#123;2,10&#125;.com$&apos;,addr):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"># 测试:</span><br><span class="line">assert is_valid_email(&apos;someone@gmail.com&apos;)</span><br><span class="line">assert is_valid_email(&apos;bill.gates@microsoft.com&apos;)</span><br><span class="line">assert not is_valid_email(&apos;bob#example.com&apos;)</span><br><span class="line">assert not is_valid_email(&apos;mr-bob@example.com&apos;)</span><br><span class="line">print(&apos;ok&apos;)</span><br></pre></td></tr></table></figure>
<p>版本二可以提取出带名字的Email地址：</p>
<ul>
<li><tom paris=""> <a href="mailto:tom@voyager.org" target="_blank" rel="noopener">tom@voyager.org</a> =&gt; Tom Paris</tom></li>
<li><a href="mailto:bob@example.com" target="_blank" rel="noopener">bob@example.com</a> =&gt; bob</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">def name_of_email(addr):</span><br><span class="line">    r = re.match(r&apos;^&lt;?([a-zA-Z]+\s?[a-zA-Z]+)&gt;?\s?[a-zA-Z]*@[a-zA-Z0-9]+.[a-zA-Z]+$&apos;, addr);</span><br><span class="line">    return r.group(1)</span><br><span class="line"># 测试:</span><br><span class="line">assert name_of_email(&apos;&lt;Tom Paris&gt; tom@voyager.org&apos;) == &apos;Tom Paris&apos;</span><br><span class="line">assert name_of_email(&apos;tom@voyager.org&apos;) == &apos;tom&apos;</span><br><span class="line">print(&apos;ok&apos;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/eleventh/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/eleventh/" itemprop="url">小圆第十一天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T17:53:47+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>多任务的实现有3种方式：</p>
<ol>
<li>多进程模式</li>
<li>多线程模式</li>
<li>多进程+多线程</li>
</ol>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Unix/Linux操作系统提供了<font color="red"><code>fork()</code></font>系统调用,它调用一次返回两次,因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程),然后分别在父进程和子进程内返回.</p>
<p>子进程永远返回<font color="red"><code>0</code></font>,父进程返回子进程的ID,一个父进程可以fork很多子进程,父进程要记下每个子进程的ID,而子进程只需要调用<font color="red"><code>getppid()</code></font>就可以拿到父进程的ID.<br>Python的<font color="red"><code>os</code></font>模块封装了常见的系统调用,包括fork:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(&apos;Process (%s) start...&apos; % os.getpid())</span><br><span class="line"># Only works on Unix/Linux/Mac:</span><br><span class="line">pid = os.fork()  #windows不能用</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;I am child process (%s) and my parent is %s.&apos; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;I (%s) just created a child process (%s).&apos; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Process (876) start...</span><br><span class="line">I (876) just created a child process (877).</span><br><span class="line">I am child process (877) and my parent is 876.</span><br></pre></td></tr></table></figure></p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>由于Windows没有<font color="red"><code>fork</code></font>调用,难道在Windows上无法使用Python编写多进程吗?</p>
<p>要记得Python是跨平台的,自然提供跨平台的多进程支持.<font color="red"><code>multiprocessing</code></font>模块就是跨平台的多进程模块.</p>
<p><font color="red"><code>multiprocessing</code></font>模块低筒了<font color="red"><code>Process</code></font>类来代表一个进程对象,下面的dome演示了启动一个子进程并等待结束:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 子进程要执行的代码</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&apos;Run child process %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&apos;test&apos;,))</span><br><span class="line">    print(&apos;Child process will start.&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;Child process end.&apos;)</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent process 928.</span><br><span class="line">Child Process will start.</span><br><span class="line">Run child process test (929)...</span><br><span class="line">Child Process end.</span><br></pre></td></tr></table></figure></p>
<p>创建子进程时,需要传入执行函数及其参数,创建一个<font color="red"><code>Process</code></font>实例,用<font color="red"><code>start()</code></font>方法启动.<font color="red"><code>join()</code></font>方法可以等待子进程结束后再继续往下运行,常用于进程间的同步.</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>如果需要创建大量的子进程,可以使用进程池的方式批量创建子进程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&apos;Run task %s (%s)...&apos; % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&apos;Task %s runs %0.2f seconds.&apos; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    print(&apos;Parent process %s.&apos; % os.getpid())</span><br><span class="line">    p = Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&apos;Waiting for all subprocesses done...&apos;)</span><br><span class="line">    p.close() #调用close()方法后就不能添加新的Process</span><br><span class="line">    p.join()#等待所有子进程执行完毕,在其前面必须先调用close()</span><br><span class="line">    print(&apos;All subprocesses done.&apos;)</span><br></pre></td></tr></table></figure></p>
<p>再看看执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process 669.</span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task 0 (671)...</span><br><span class="line">Run task 1 (672)...</span><br><span class="line">Run task 2 (673)...</span><br><span class="line">Run task 3 (674)...</span><br><span class="line">Task 2 runs 0.14 seconds.</span><br><span class="line">Run task 4 (673)...</span><br><span class="line">Task 1 runs 0.27 seconds.</span><br><span class="line">Task 3 runs 0.86 seconds.</span><br><span class="line">Task 0 runs 1.41 seconds.</span><br><span class="line">Task 4 runs 1.91 seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p>
<p>我们注意到task<font color="red"><code>4</code></font>要等待前面某个task完成后才执行,因为<font color="red"><code>Pool</code></font>的默认大小是CPU的核数,使用<font color="red"><code>Pool</code></font>来进行有意的限制,如果改成<code>p=Pool(5)</code>就可以跑5个进程.</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p><font color="red"><code>subprocess</code></font>模块可以让我我们非常方便地启动一个子进程,然后控制其输入和输出.下面的demo演示在Python代码中运行命令<font color="red"><code>nslookup www.python.org</code></font>,这和命令行直接运行的效果是一样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&apos;$ nslookup www.python.org&apos;)</span><br><span class="line">r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])</span><br><span class="line">print(&apos;Exit code:&apos;, r)</span><br></pre></td></tr></table></figure></p>
<p>如果子进程需要输入,可以通过<font color="red"><code>communicate()</code></font>方法输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&apos;$ nslookup&apos;)</span><br><span class="line">p = subprocess.Popen([&apos;nslookup&apos;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(b&apos;set q=mx\npython.org\nexit\n&apos;)</span><br><span class="line">print(output.decode(&apos;utf-8&apos;))</span><br><span class="line">print(&apos;Exit code:&apos;, p.returncode)</span><br></pre></td></tr></table></figure></p>
<p>相当于在命令行执行命令<font color="red"><code>nslookup</code></font>然后手动输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set q=mx</span><br><span class="line">python.org</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><font color="red"><code>Process</code></font>之间肯定是需要通信的,Python的<font color="red"><code>multiprocessing</code></font>模块包装了底层的机制,提供了<font color="red"><code>Queuep</code></font>,<font color="red"><code>Pipes</code></font>等多种方式来交换数据.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    print(&apos;Process to write: %s&apos; % os.getpid())</span><br><span class="line">    for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">        print(&apos;Put %s to queue...&apos; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    print(&apos;Process to read: %s&apos; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)#这里传入了True 而默认timeout=None,所以当q中没有数据时会一直阻塞,后面的打印也不会执行</span><br><span class="line">        print(&apos;Get %s from queue.&apos; % value)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Process to write: 50563</span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: 50564</span><br><span class="line">Get A from queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B from queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C from queue.</span><br></pre></td></tr></table></figure></p>
<p>在Unix/Linux下,<font color="red"><code>multiprocessing</code></font>模块封装了<font color="red"><code>fork()</code></font>的细节,因为Windows没有<font color="red"><code>fork</code></font>调用,所以<font color="red"><code>multiprocessing</code></font>需要模拟出<font color="red"><code>fork</code></font>的效果,父进程所有的python对象都必须通过pickle序列化后传到子进程,所以如果<font color="red"><code>multiprocessing</code></font>在Windows下调用失败很有可能是pickle失败了.</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>由于线程是操作系统直接支持的执行单元,因此,高级语言通常都内置多线程的支持,Python也不例外,并且Python的线程是真正的Posix Thread,而不是模拟出来的线程.</p>
<p>Python的标准库提供了两个模板:<font color="red"><code>_thread</code></font>和<font color="red"><code>threading</code></font>,其中<font color="red"><code>threading</code></font>是高级模块对<font color="red"><code>_thread</code></font>进行了封装.因此大多数情况下我们使用<font color="red"><code>threading</code></font>就可以了.</p>
<p>启动一个线程就是把一个函数传入并创建<font color="red"><code>thread</code></font>实例,然后调用<font color="red"><code>start()</code></font>开始执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread LoopThread is running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 1</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 2</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 3</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 4</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 5</span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure></p>
<p>因为进程默认启动一个线程,我们称该线程为主线程,主线程可以启动新的线程,Python的<font color="red"><code>threading</code></font>模块有个<font color="red"><code>current_thread()</code></font>函数,返回当前线程的实例,主线程实例的名字叫<font color="red"><code>MainThread</code></font>子线程的名字在创建中给出,上面叫做<font color="red"><code>LoopThread</code></font>,也可以不写默认起名为<font color="red"><code>Thread-1</code></font>,<font color="red"><code>Thread-2</code></font>…</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>多进程和多线程最大的不同在于:多进程中,同一个变量在不同进程中有一份拷贝,互不影响,而在多线程中所有变量都由所有线程共享,因此有可能多个线程修改同一个变量,把内容改乱了.demo如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 假定这是你的银行存款:</span><br><span class="line">balance = 0</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该为0:</span><br><span class="line">    global balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line">    #如果在这里加上一个print()语句会发现无论运行多少次都没有错,</span><br><span class="line">    #这是因为当函数本身的操作很少时,print()操作的耗时不能忽略,</span><br><span class="line">    #导致冲突的概率下降99%,所以做性能测试的时候不能有print()语句</span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(5,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></p>
<p>执行结果可能不是0,因为高级语言的一条语句在CPU执行时是若干条语句,即使是一个简单的计算<code>balance = balance + n</code>,分为两步:</p>
<ol>
<li>计算balance+n,存入临时变量中;</li>
<li>降临时变量的值赋值给balance.</li>
</ol>
<p>也可以看成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = balance + n</span><br><span class="line">balance = x</span><br></pre></td></tr></table></figure></p>
<p>x是局部变量,每个线程都有自己的x,线程是交替运行的,在执行语句的时候,线程可能被其他线程打断,从而导致把同一个对象的内容改乱.</p>
<p>为了避免这种情况,我们可以给<font color="red"><code>change_it()</code></font>上一把锁,当某个线程执行<font color="red"><code>change_it()</code></font>时,该线程获得了锁,其他线程不能同时执行<font color="red"><code>change_it()</code></font>,只有该锁被释放后,获得该锁以后才能改.同一时刻只有一个线程拿到该锁,因此不会造成修改冲突,我们通过<font color="red"><code>threading.Lock()</code></font>来创建一个锁.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure></p>
<h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><p>我们试试写一个死循环:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import threading, multiprocessing</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    x = 0</span><br><span class="line">    while True:</span><br><span class="line">        x = x ^ 1</span><br><span class="line"></span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p>
<p>我运行后发现只占用了一核,但是我明明创建了4个线程,为啥没跑满呢?<br>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁,这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核.所以多线程的并发在Python中就是一个美丽的梦.</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多线程环境下,每个线程都有自己的局部变量,局部变量不会影响到其他线程,而全局变量的修改必须加锁.<br>但局部变量也有问题,就是在调用的时候传递很麻烦.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def process_student(name):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    # std是局部变量，但是每个函数都要用它，因此必须传进去：</span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line">def do_task_1(std):</span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line"></span><br><span class="line">def do_task_2(std):</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br></pre></td></tr></table></figure></p>
<p>每个函数一层一层传那还写什么代码…那么改为全局变量?也不行,因为每个线程处理不同的<font color="red"><code>Student</code></font>对象,不能共享.</p>
<p>如果用一个全局<font color="red"><code>dict</code></font>存放所有的<font color="red"><code>Student</code></font>对象,然后以<font color="red"><code>thread</code></font>自身的key获得线程对应的<font color="red"><code>Student</code></font>对象如何?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">def std_thread(name):</span><br><span class="line">    std = Student(name)</span><br><span class="line">    # 把std放到全局变量global_dict中：</span><br><span class="line">    global_dict[threading.current_thread()] = std</span><br><span class="line">    do_task_1()</span><br><span class="line">    do_task_2()</span><br><span class="line"></span><br><span class="line">def do_task_1():</span><br><span class="line">    # 不传入std，而是根据当前线程查找：</span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">def do_task_2():</span><br><span class="line">    # 任何函数都可以查找出当前线程的std变量：</span><br><span class="line">    std = global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>理论上是可以,消除了传递问题,但是看着有点丑,我们有更简单的<font color="red"><code>ThreadLocal</code></font>,不用查找<font color="red"><code>dict</code></font>,<font color="red"><code>ThreadLocal</code></font>帮你做这件事:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象:</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Alice (in Thread-A)</span><br><span class="line">Hello, Bob (in Thread-B)</span><br></pre></td></tr></table></figure></p>
<p>全局变量<font color="red"><code>local_school</code></font>就是一个<font color="red"><code>ThreadLocal</code></font>对象,每个<font color="red"><code>Thread</code></font>对它都可以读写<font color="red"><code>student</code></font>属性,但互不影响,可以把<font color="red"><code>local_school</code></font>看成全局变量,但每个属性如<font color="red"><code>local_school.student</code></font>都是线程的局部变量,可以任意读写不干扰,也不要管理锁问题,<font color="red"><code>ThreadLocal</code></font>内部会处理.</p>
<p>也可以理解为全局变量<font color="red"><code>dlocal_school</code></font>是一个<font color="red"><code>dict</code></font>,不但可以用<font color="red"><code>local_school.student</code></font>,还可以绑定其他变量,如<font color="red"><code>local_school.teacher</code></font>等等</p>
<h2 id="进程-VS-线程"><a href="#进程-VS-线程" class="headerlink" title="进程 VS 线程"></a>进程 VS 线程</h2><p>多任务的两种方式：多进程和多线程。如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是稳定性高，缺点是创建代价大过多的线程切换消耗资源。<br>计算密集型任务:使用像C语言，实现效率较高<br>IO密集型任务:使用脚本语言 例如python开发效率最高</p>
<p>异步IO，Python语言，单线程的异步编程模型称为协程</p>
<h2 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h2><p>在Thread和Process中,应当优选Process,因为进程更稳定,而且Process可以分布到多台机器上,而Thread最多只能分布到同一台机器的多个CPU上.</p>
<p>其中Python的<font color="red"><code>multiprocessing</code></font>模块不但支持多进程,其中的<font color="red"><code>managers</code></font>子模块还支持把多进程分布到多台机器上.</p>
<p>举个栗子:如果我们已经有一个通过<font color="red"><code>queue</code></font>通信的多进程程序在同一台机器上运行,现在由于这台机器太慢,我们有找来另一台机器帮他分担任务,我们怎么用分布式进程实现?</p>
<p>原有的<font color="red"><code>Queue</code></font>可以继续使用,通过<font color="red"><code>managers</code></font>模块把<font color="red"><code>Queue</code></font>通过网络暴露出去,就可以让其他机器进程访问<font color="red"><code>Queue</code></font>了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import random,time,queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 发送任务的队列:</span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"># 接收结果的队列:</span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line">#替代原来的匿名函数</span><br><span class="line">def return_task_queue():</span><br><span class="line">    global task_queue</span><br><span class="line">    return task_queue</span><br><span class="line">#替代原来的匿名函数</span><br><span class="line">def return_result_queue():</span><br><span class="line">    global result_queue</span><br><span class="line">    return result_queue</span><br><span class="line"># 从BaseManager继承的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br><span class="line">    QueueManager.register(&apos;get_task_queue&apos;, callable=return_task_queue)</span><br><span class="line">    QueueManager.register(&apos;get_result_queue&apos;, callable=return_result_queue)</span><br><span class="line">    # 绑定端口5000, 设置验证码&apos;abc&apos;:</span><br><span class="line">    manager = QueueManager(address=(&apos;127.0.0.1&apos;, 5000), authkey=b&apos;abc&apos;)</span><br><span class="line">    #    启动Queue:</span><br><span class="line">    manager.start()</span><br><span class="line">    # 获得通过网络访问的Queue对象:</span><br><span class="line">    task = manager.get_task_queue()</span><br><span class="line">    result = manager.get_result_queue()</span><br><span class="line">    # 放几个任务进去:</span><br><span class="line">    for i in range(10):</span><br><span class="line">        n = random.randint(0, 10000)</span><br><span class="line">        print(&apos;Put task %d...&apos; % n)</span><br><span class="line">        task.put(n)</span><br><span class="line">    # 从result队列读取结果:</span><br><span class="line">    print(&apos;Try get results...&apos;)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        r = result.get(timeout=10)</span><br><span class="line">        print(&apos;Result: %s&apos; % r)</span><br><span class="line">    # 关闭:</span><br><span class="line">    manager.shutdown()</span><br><span class="line">    print(&apos;master exit.&apos;)</span><br></pre></td></tr></table></figure></p>
<p>请注意,当我们在一台机器上写多进程时,创建的<font color="red"><code>Queue</code></font>可以直接拿过来用,但是分布式多进程环境下,不可以直接对原始的<font color="red"><code>task_queue</code></font>进行操作,那样就绕过了<font color="red"><code>QueueManager</code></font>的封装,必须通过<font color="red"><code>manager.get_task_queue</code></font>获得的Queue接口添加.</p>
<p>然后在另一台机器上启动任务进程(本机也可以)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import time, sys, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 创建类似的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br><span class="line">QueueManager.register(&apos;get_task_queue&apos;)</span><br><span class="line">QueueManager.register(&apos;get_result_queue&apos;)</span><br><span class="line"></span><br><span class="line"># 连接到服务器，也就是运行task_master.py的机器:</span><br><span class="line">server_addr = &apos;127.0.0.1&apos;</span><br><span class="line">print(&apos;Connect to server %s...&apos; % server_addr)</span><br><span class="line"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br><span class="line">m = QueueManager(address=(server_addr, 5000), authkey=b&apos;abc&apos;)</span><br><span class="line"># 从网络连接:</span><br><span class="line">m.connect()</span><br><span class="line"># 获取Queue的对象:</span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"># 从task队列取任务,并把结果写入result队列:</span><br><span class="line">for i in range(10):</span><br><span class="line">    try:</span><br><span class="line">        n = task.get(timeout=1)</span><br><span class="line">        print(&apos;run task %d * %d...&apos; % (n, n))</span><br><span class="line">        r = &apos;%d * %d = %d&apos; % (n, n, n*n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        result.put(r)</span><br><span class="line">    except Queue.Empty:</span><br><span class="line">        print(&apos;task queue is empty.&apos;)</span><br><span class="line"># 处理结束:</span><br><span class="line">print(&apos;worker exit.&apos;)</span><br></pre></td></tr></table></figure></p>
<p>我们下面可以测试分布式进程的工作效果,先启动<code>task_master.py</code>服务进程,发送完任务后,开始等待<code>result</code>队列的结果.然后启动<code>task_worker.py</code>进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ python3 task_master.py</span><br><span class="line">Put task 3411...</span><br><span class="line">Put task 1605...</span><br><span class="line">Put task 1398...</span><br><span class="line">Put task 4729...</span><br><span class="line">Put task 5300...</span><br><span class="line">Put task 7471...</span><br><span class="line">Put task 68...</span><br><span class="line">Put task 4219...</span><br><span class="line">Put task 339...</span><br><span class="line">Put task 7866...</span><br><span class="line">Try get results...</span><br><span class="line">#result队列</span><br><span class="line">$ python3 task_worker.py</span><br><span class="line">Connect to server 127.0.0.1...</span><br><span class="line">run task 3411 * 3411...</span><br><span class="line">run task 1605 * 1605...</span><br><span class="line">run task 1398 * 1398...</span><br><span class="line">run task 4729 * 4729...</span><br><span class="line">run task 5300 * 5300...</span><br><span class="line">run task 7471 * 7471...</span><br><span class="line">run task 68 * 68...</span><br><span class="line">run task 4219 * 4219...</span><br><span class="line">run task 339 * 339...</span><br><span class="line">run task 7866 * 7866...</span><br><span class="line">worker exit.</span><br></pre></td></tr></table></figure></p>
<p><code>task_worker.py</code>进程结束后,在<code>task_master.py</code>进程中继续打印结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Result: 3411 * 3411 = 11634921</span><br><span class="line">Result: 1605 * 1605 = 2576025</span><br><span class="line">Result: 1398 * 1398 = 1954404</span><br><span class="line">Result: 4729 * 4729 = 22363441</span><br><span class="line">Result: 5300 * 5300 = 28090000</span><br><span class="line">Result: 7471 * 7471 = 55815841</span><br><span class="line">Result: 68 * 68 = 4624</span><br><span class="line">Result: 4219 * 4219 = 17799961</span><br><span class="line">Result: 339 * 339 = 114921</span><br><span class="line">Result: 7866 * 7866 = 61873956</span><br></pre></td></tr></table></figure></p>
<h3 id="import-queue-与from-multiprocessing-import-Queue"><a href="#import-queue-与from-multiprocessing-import-Queue" class="headerlink" title="import queue 与from multiprocessing import Queue"></a>import queue 与from multiprocessing import Queue</h3><ol>
<li>from Queue import Queue这个是普通的队列模式，类似于普通列表，先进先出模式，get方法会阻塞请求，直到有数据get出来为止</li>
<li>from multiprocessing.Queue import Queue这个是多进程并发的Queue队列，用于解决多进程间的通信问题。普通Queue实现不了。例如来跑多进程对一批IP列表进行运算，运算后的结果都存到Queue队列里面，这个就必须使用multiprocessing提供的Queue来实现</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/tenth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tenth/" itemprop="url">小圆第十天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-27T21:53:14+08:00">
                2018-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<ol>
<li>基本概念：input， output，stream</li>
<li>存在问题：输入和接收速度不匹配</li>
<li>解决方法：同步、异步(回调–好了叫我，轮询—好了没…好了没)</li>
<li>收获新知：编程语言都会把操作系统提供的低级C接口封装起来方便使用<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2>读写文件时最常见的IO操作,用法和C兼容.<br>因为现代的操作系统不允许普通的程序直接操作磁盘,所以读写文件就是请求操作系统打开一个文件对象,通过操作系统这个接口从文件对象中读取数据,或者写入数据.<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3>要读取一个文件,使用Python内置的<font color="red"><code>open()</code></font>函数.传入文件名和标识符.<br><code>&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)</code><br>标识符’r’表示读,这样我们就成功的打开了一个文件,如果文件不存在<font color="red"><code>open()</code></font>函数会抛出错误信息.</li>
</ol>
<p>如果文件成功打开,调用<font color="red"><code>read()</code></font>方法可以一次读取文件的全部内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;Hello, world!&apos;</span><br></pre></td></tr></table></figure></p>
<p>最后一步就是调用<font color="red"><code>close()</code></font>方法关闭文件.文件使用后必须关闭,否则会占用资源,并且同一时间内操作系统打开的文件数量也是有限的:<code>&gt;&gt;&gt; f.close()</code></p>
<p>由于文件读写时都有可能出现<font color="red"><code>IOError</code></font>,一旦出错,后面的<font color="red"><code>f.close()</code></font>就不会调用,所以我们可以使用<font color="red"><code>try ... finally</code></font>来避免这种情况.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></p>
<p>每次这么写我可不干,Python引入了<font color="red"><code>with</code></font>语句来自动帮我们调用<font color="red"><code>close()</code></font>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure></p>
<p>这其实和前面的<font color="red"><code>try ... finally</code></font>一样.</p>
<p>调用<font color="red"><code>read()</code></font>会一次性读取全部内容,如果内容太大,内存就会炸掉,所以保险起见,可以反复调用<font color="red"><code>read(size)</code></font>方法,每次最多读取size个字节的内容,另外调用<font color="red"><code>readline()</code></font>可以每次读取一行内容,调用<font color="red"><code>readlines()</code></font>一次性读取所有内容并按行返回<font color="red"><code>list</code></font>.</p>
<p>如果文件小就用read(),如果不确定就用read(size),如果是配置文件就用readlines()最方便:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip()) # 把末尾的&apos;\n&apos;删掉</span><br></pre></td></tr></table></figure></p>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>前面所有的都是读取文本文件,并且是UTF-8的文本文件,如果要读取二进制文件,比如图片,视频等,用<font color="red"><code>&#39;rb&#39;</code></font>模式打开文件就可以啦:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节</span><br></pre></td></tr></table></figure></p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>尧都区非UTF-8编码的文本文件,需要给<font color="red"><code>open()</code></font>函数传入<font color="red"><code>encoding</code></font>参数,例如读取GBK编码的文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;测试&apos;</span><br></pre></td></tr></table></figure></p>
<p>有时候编码不规范的文件会遇到<font color="red"><code>UnicodeDecodeError</code></font>,因为文件里掺杂了一下非法编码的字符,这时让<font color="red"><code>open()</code></font>函数接受一个<font color="red"><code>errors</code></font>参数,表示遇到编码错误如何处理,最简单的方法就是直接忽略<br><code>&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件类似,只是把<font color="red"><code>open()</code></font>函数传入的标识为<font color="red"><code>&#39;w&#39;</code></font>或者<font color="red"><code>&#39;wb&#39;</code></font>标识写文件或者二进制文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>注意,写文件的时候操作系统不会立刻把数据写入磁盘,而是先放到内存缓存起来,只有调用<font color="red"><code>close()</code></font>方法时,操作系统才保证把没有写入磁盘的数据全部写入.所以我们还是乖乖的用<font color="red"><code>with</code></font>语句保险..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure></p>
<p>要写入特定的文本文件依然给<font color="red"><code>open()</code></font>函数传入<font color="red"><code>encoding</code></font>参数,将字符串转换成制定编码.</p>
<p>直接写文件的话,如果文件已存在会把之前的文件内容删掉然后再写,那么我们希望增加怎么办?可以传入<font color="red"><code>&#39;a&#39;</code></font>来进行追加.</p>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候数据读写不一定是文件,也可以在内存中读写,StringIO就是在内存 中读写str.要把str写入StringIO,我们需要先创建一个StringIO,然后像文件一样写入即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.write(&apos; &apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;world!&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>getvalue()</code></font>方法用于获得写入后的str.要读取StringIO,可以使用一个str初始化StringIO,然后像文件一样读取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s = f.readline()</span><br><span class="line">...     if s == &apos;&apos;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure></p>
<h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO只能操作str,如果要操作二进制数据,就需要使用BytesIO.依然先创建一个BytesIO,然后进行读写bytes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line"># 也可以先初始化然后读取</span><br><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="StringIO与BytesIO小结"><a href="#StringIO与BytesIO小结" class="headerlink" title="StringIO与BytesIO小结"></a>StringIO与BytesIO小结</h3><p>比如说,你需要对获取到的数据进行操作,但是你并不想把本地数据写到本地硬盘上,这时候你就可以使用StringIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">from io import BytesIO</span><br><span class="line">def outputstring():</span><br><span class="line">    return &apos;string \nfrom \noutputstring \nfunction&apos;</span><br><span class="line"></span><br><span class="line">s = outputstring()</span><br></pre></td></tr></table></figure></p>
<p>将函数返回的数据在内存中读:<code>sio = StringIO(s)</code>,也可以使用StringIO本身的方法<code>print(sio.getvalue())</code>,也可以使用file-like object的方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = sio.readlines()</span><br><span class="line">for i in s:</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>将函数返回的数据在内存中写:<code>sio = StringIO()</code>,<code>sio.write(s)</code>,也可以使用String本身的方法查看<code>s=sio.getvalue(),print(s)</code></p>
<p>这时,如果你使用file-like object方法查看时,你会发现数据为空.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line">for i in sio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>我们需要修改文件的指针位置,然后就发现内容居然可以打印了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line">sio.seek(0,0)</span><br><span class="line">print(sio.tell())</span><br><span class="line">for i in sio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到两个方法<font color="red"><code>seek()</code></font>和<font color="red"><code>tell()</code></font>:</p>
<p>tell()用来回去当前文件读取指针的位置</p>
<p>seek()用来移动文件读写指针的指定位置,有两个参数,第一个<font color="red"><code>offset</code></font>:偏移量,需要向前或向后的字节数,正为向前,负为向后;第二个<font color="red"><code>whence</code></font>:可选值,默认为0,表示文件开头,1表示相对于当前位置,2表示文件末尾.</p>
<p>注意使用seek时,如果你的打开的文件没有使用<font color="red"><code>&#39;b&#39;</code></font>的方式打开,则offset无法使用负值.</p>
<p>StringIO只能操作str,要操作二进制数据就要用到BytesIO,并且上面的sio不能使用seek从当前位置向前移动,这时我们使用’b’的方式写入数据,就可以向前移动了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bio = BytesIO()</span><br><span class="line">bio.write(s.encode(&apos;utf-8&apos;))</span><br><span class="line">print(bio.getvalue())</span><br><span class="line">bio.seek(-36,1)</span><br><span class="line">print(bio.tell())</span><br><span class="line">for i in bio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>我们要操作文件,目录,可以在命令行下输入操作系统提供的命令就可以,那么在Python中怎么玩呢?</p>
<p>其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数,Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name</span><br><span class="line">&apos;nt&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果是<font color="red"><code>posix</code></font>说明操作系统是linux,Unix,或是Mac OS X,如果是nt,就是windows系统.我们还可以使用<font color="red"><code>uname()</code></font>函数来获取更详细的系统信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.uname()</span><br><span class="line">posix.uname_result(sysname=&apos;Darwin&apos;, nodename=&apos;MichaelMacPro.local&apos;, release=&apos;14.3.0&apos;, version=&apos;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&apos;, machine=&apos;x86_64&apos;)</span><br></pre></td></tr></table></figure></p>
<p>注意<font color="red"><code>uname()</code></font>函数在windows上不提供,也就是说os模块的某些函数时跟操作系统相关的.</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>操作系统的环境变量保存在<font color="red"><code>os.environ</code></font>这个变量中,可以直接查看<code>os.environ</code>,要获取摸个环境变量的值可以调用<font color="red"><code>os.environ,get(&#39;key&#39;)</code></font>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&apos;PATH&apos;)</span><br><span class="line">&apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&apos;</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;x&apos;, &apos;default&apos;)</span><br><span class="line">&apos;default</span><br></pre></td></tr></table></figure></p>
<h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数一部分在<font color="red"><code>os</code></font>模块中,一部分在<font color="red"><code>os.path</code></font>模块中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br></pre></td></tr></table></figure></p>
<p>两个路径合并成一个时,要通过<font color="red"><code>os.path.join()</code></font>函数,而拆分时要通过<font color="red"><code>os.path.split()</code></font>函数,注意,后一部分总是最后级别的目录或者文件名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>os.path.splitext()</code></font>可以直接让你得到文件的扩展名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面这些合并,拆分路径的函数并不要求目录和文件要真实存在,他们只对字符串进行操作.下面假设有一个<font color="red"><code>test.txt</code></font>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure></p>
<p>复制文件的函数在os模块中不存在!因为操作系统没有提供系统调用,幸运的是<font color="red"><code>shutil</code></font>模块提供了<font color="red"><code>copyfile()</code></font>的函数.</p>
<p>最后看看如何过滤文件.要求列出当前目录下的所有目录,以及所有的<font color="red"><code>.py</code></font>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#当前文件下所有目录</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br><span class="line">#当前文件下的所有.py文件</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure></p>
<h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p>编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def mysearch(path,str):</span><br><span class="line">    for x in os.listdir(path):</span><br><span class="line">        _path=os.path.join(path,x)</span><br><span class="line">        if os.path.isdir(_path):</span><br><span class="line">            mysearch(_path,str)</span><br><span class="line">        else:</span><br><span class="line">            if str in x:</span><br><span class="line">                print(_path)</span><br><span class="line">mysearch(&apos;.&apos;,&apos;a&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在程序运行的过程中,所有的变量都是在内存中,我们定义一个dict:<code>d = dict(name=&#39;Bob&#39;, age=20, score=88)</code>,我们可以随意的修改变量的值,但是程序一旦结束,变量所占用的内存就被操作系统全部收回,如果修改后的变量没有存储到磁盘上,下次还是会被初始化.</p>
<p>我们吧变量从内存变为可存储或传输的过程叫做序列化,序列化后我们就可以把内容写入磁盘或者通过网络传输.返过来,把变量内容从序列化的对象从新读到内存称为反序列化,Python提供了<font color="red"><code>pickle</code></font>,模块来实现序列化.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>pickle.dumps()</code></font>方法吧任意对象序列化成一个<font color="red"><code>bytes</code></font>,然后就可以把这个bytes写入文件或者用另一个方法<font color="red"><code>pickle.dump()</code></font>直接序列化后写入一个file-like object:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>那么反序列化和序列化类似,我们可以先把内容读到一个<font color="red"><code>bytes</code></font>,然后使用<font color="red"><code>pickle.loads()</code></font>方法反序列化出对象,当然也可以使用<font color="red"><code>pickle.load()</code></font>方法直接序列化写入对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式,JSON表示出来就是一个字符串,可以被所有语言读取,也方便存储和传输.</p>
<p>python内置的<font color="red"><code>json</code></font>模块提供了python对象到JSON格式的转换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>dumps()</code></font>方法返回一个str,内容就是标准的JSON,类似,<font color="red"><code>dump()</code></font>方法可以直接把JSON写入一个file-like object</p>
<p>JSON的反序列化为Python对象依然使用<font color="red"><code>load()</code></font>或者<font color="red"><code>loads()</code></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的<font color="red"><code>dict</code></font>对象可以直接序列化为JSON的’{}’,有时候我们跟喜欢用<font color="red"><code>class</code></font>表示对象,然后序列化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Bob&apos;, 20, 88)</span><br><span class="line">print(json.dumps(s))</span><br></pre></td></tr></table></figure></p>
<p>运行代码,毫不留情的get到一个<font color="red"><code>TypeError</code></font>,原因是Student不是一个可序列化的JSON对象,这时我们看看dumps()的参数列表.</p>
<p>dumps()的参数列表中除了第一个必须的<font color="red"><code>obj</code></font>参数外,还有很多可选参数,这些可选参数就是让我们来定制JSON序列化,因为默认情况下<font color="red"><code>dumps()</code></font>方法不知道如何将Student实例变为一个JSON的’{}’对象.</p>
<p>可选参数<font color="red"><code>default</code></font>就是把任意一个对象变成可序列化的JSON对象,我们需要专门写一个转换函数,再把函数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age,</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">    #这样student首先被转换函数转化成dict,然后被顺利的序列化为JSON:</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过下次遇到一个<font color="red"><code>teacher</code></font>类的实例,照样不能序列化为JSON,我们可以偷个懒,把任意<font color="red"><code>class</code></font>的实例变为<font color="red"><code>dict</code></font>:<br><code>print(json.dumps(s, default=lambda obj: obj.__dict__))</code></p>
<p>因为通常<font color="red"><code>class</code></font>的实例都有一个<font color="red"><code>__dict__</code></font>属性,它就是一个<font color="red"><code>dict</code></font>除了少数的例外,比如定义了<font color="red"><code>__slots__</code></font>的class</p>
<p>同样的道理我们要把JSON反序列化为一个<font color="red"><code>Student</code></font>对象实例,<font color="red"><code>loads()</code></font>方法首先转换出一个<font color="red"><code>dict</code></font>对象,然后我们传入的<font color="red"><code>object_hook</code></font>函数负责把dict转换为Student实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">#运行结果如下:</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/ninth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ninth/" itemprop="url">小圆第九天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-26T20:50:55+08:00">
                2018-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h1><p>做为一名伪程序员，最讨厌的事情肯定是程序出bug啦！在程序运行中，总会遇到各种各样的错误，这时候就需要我们来调试，让他们能够正常运行。</p>
<p>有些错误时程序编写的错误,有的时候是用户输入造成的,还有些错误在程序运行过程中无法预测,比如:写文件的时候磁盘满了,网络抓取数据的时候网络掉了.这类错误称为异常,而我们要做的事情就是解决这些异常.</p>
<p>解决办法:<br>1、跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。</p>
<p>2、Python的pdb可以让我们以单步方式执行代码。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在程序运行过程中如果出现错误,我么可以事先约定一个错误代码,这样就知道是否出错以及出错的原因,比如打开文件的函数<font color="red"><code>open()</code></font>,成功时返回文件描述符(一个整数),出错时返回<font color="red"><code>-1</code></font>.</p>
<p>但是用错误码来表示出错不方便,而且有可能和正确结果混在一起.所以高级语言里内置了<font color="red"><code>try...except...finally...</code></font>的错误机制,Python当然也有.</p>
<h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / 0</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;except:&apos;, e)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure>
<p>当我们认为某段代码可能出错时,我们把这段代码放到<font color="red"><code>try</code></font>里运行,如果出错,后面代码不会继续运行转到<font color="red"><code>except</code></font>语句块.<font color="red"><code>except</code></font>是用来<font color="red"><code>捕捉</code></font>错误信息的代码处理块.执行完<font color="red"><code>except</code></font>后,如果有<font color="red"><code>finally</code></font>语句快则执行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#上面代码结果</span><br><span class="line">try...</span><br><span class="line">except: division by zero</span><br><span class="line">finally...</span><br><span class="line">END</span><br><span class="line">#试着把除数0改成5</span><br><span class="line">try...</span><br><span class="line">result: 5</span><br><span class="line">finally...</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
<p>由于没有错误,所以<font color="red"><code>except</code></font>语句块不会执行,但是有<font color="red"><code>finally</code></font>一定会执行.</p>
<p>我们还可以有多种错误,可以用不同的<font color="red"><code>except</code></font>语句快捕捉.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;a&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure></p>
<p>在except后面加上一个<font color="red"><code>else</code></font><br>,当没有错误时自动执行.</p>
<p>其实Python的错误也是class.都继承于<font color="red"><code>BaseException</code></font>,所以捕捉错误时可以把子类的错误也捕捉到.实例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    foo()</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError&apos;)</span><br><span class="line">except UnicodeError as e:#永远不会捕捉到错误,以为它是ValueError的子类</span><br><span class="line">    print(&apos;UnicodeError&apos;)</span><br></pre></td></tr></table></figure></p>
<p>使用<font color="red"><code>try...except</code></font>捕捉错误还有一个巨大的好处,可以跨越多层调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">#其实在这里出错了</span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        bar(&apos;0&apos;)</span><br><span class="line">    except Exception as e:#在main()函数里也可以捕捉到其他调用函数的错误</span><br><span class="line">        print(&apos;Error:&apos;, e)</span><br><span class="line">    finally:</span><br><span class="line">        print(&apos;finally...&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>如果错误没有没捕获,他就会一直向上抛,最后被Python解释器捕获,打印一个错误信息,然后程序退出.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    return 10 / int(s)</span><br><span class="line"></span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<p>执行,结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;err.py&quot;, line 9, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">  File &quot;err.py&quot;, line 6, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err.py&quot;, line 3, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p>
<p>我们从上往下就可以看到整个错误的调用函数链:<font color="red">出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</font></p>
<h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>如果我们不捕获错误,自然可以让Python解释器来打印出错误堆栈,但是程序也结束了,我们可以用<font color="red"><code>logging</code></font>记录错误信息,同时让程序继续运行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    return 10 / int(s)</span><br><span class="line"></span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        bar(&apos;0&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure></p>
<p>这样同样是出错,但是最后会打印<font color="red">end</font>,程序继续执行并正常退出.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err_logging.py</span><br><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err_logging.py&quot;, line 13, in main</span><br><span class="line">    bar(&apos;0&apos;)</span><br><span class="line">  File &quot;err_logging.py&quot;, line 9, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err_logging.py&quot;, line 6, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
<h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>之前提到错误也是class,Python内置函数有很多类型的错误,我们也可以自己编写函数抛出错误.但要注意选择好继承关系,然后用<font color="red"><code>raise</code></font>语句抛出一个错误的实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FooError(ValueError):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure></p>
<p>执行,照样也可以跟踪到我们自己定义的错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python3 err_raise.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">  File &quot;err_throw.py&quot;, line 8, in foo</span><br><span class="line">    raise FooError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">__main__.FooError: invalid value: 0</span><br></pre></td></tr></table></figure></p>
<p>只要必要的时候才自己定义错误类型,尽量使用Python内置的错误类型.</p>
<p>我们再看另一种处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise ValueError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def bar():</span><br><span class="line">    try:</span><br><span class="line">        foo(&apos;0&apos;)</span><br><span class="line">    except ValueError as e:</span><br><span class="line">        print(&apos;ValueError!&apos;)</span><br><span class="line">        raise   #这里没有具体的错误抛出</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure></p>
<p>还是先看抛出的错误结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ValueError!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:/start/hello.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    bar()</span><br><span class="line">  File &quot;D:/start/hello.py&quot;, line 9, in bar</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">  File &quot;D:/start/hello.py&quot;, line 4, in foo</span><br><span class="line">    raise ValueError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">ValueError: invalid value: 0</span><br></pre></td></tr></table></figure></p>
<p>首先在<font color="red"><code>bar()</code></font>函数中已经捕获到错误,但是打印<font color="red"><code>ValueError!</code></font>后又把错误通过<font color="red"><code>raise</code></font><br>语句抛出去,这是为啥?<br>其实能这就相当于你老板让解决一个事情,但是有个小问题你解决不了,最恰当的动作就是抛给你老板,让老板解决,这里的<font color="red"><code>raise</code></font>就是不知道什么错误,向上抛,让其他人去解决.</p>
<p><font color="red"><code>raise</code></font>语句如果不带参数,会把错误原样抛出.</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>当程序员写程序时能够运行的概率很小,因此我们常常需要调试,第一种方法很简单,就是把你认为可能有问题的变量都打印出来.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    print(&apos;&gt;&gt;&gt; n = %d&apos; % n)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>
<p>这种办法在程序比较简单的时候可以使用,要不然你加完<font color="red"><code>print()</code></font>之后还要删,想想就很麻烦.</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>凡是用print()来查看的地方都可以使用断言(assert)来代替:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>assert</code></font>的意思是,表达式<font color="red"><code>n!=0</code></font>应该是<font color="red"><code>True</code></font>否则后面代码会出错,如果断言失败<font color="red"><code>assert</code></font>语句本身会抛出<font color="red"><code>AssertionError</code></font>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AssertionError: n is zero!  #assert后面的字符串</span><br></pre></td></tr></table></figure></p>
<p>如果程序中到处是assert和print其实也差不多,不过Python可以使用<font color="red"><code>-0</code></font>参数来关闭<font color="red"><code>assert</code></font>：<code>python -O err.py</code>,关闭后的<font color="red"><code>assert</code></font>可以当做<font color="red"><code>pass</code></font>来看.</p>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>在前面记录文件的时候说过,logging可以记录错误,而且可以输出到文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&apos;n = %d&apos; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>logging.ingo()</code></font>可以输出一段文本.但是发现除了<font color="red"><code>ZeroDivisionError</code></font>,没有任何问题,但是当我们加入在<font color="red"><code>import logging</code></font>之后添加<font color="red"><code>logging.basicConfig(level=logging.INFO)</code></font>后看看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python err.py</span><br><span class="line">INFO:root:n = 0  #打印出原因</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print(10 / n)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>import logging</code></font>可以允许你制定信息的级别有<font color="red"><code>debug</code></font><br>,<font color="red"><code>info</code></font>,<font color="red"><code>warning</code></font>,<font color="red"><code>error</code></font>等几个级别,当我们指定<font color="red"><code>level=INFO</code></font>时,<font color="red"><code>logging.debug</code></font>就不起作用了,这样就可以控制不同级别的输出信息.</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试就是用来对一个模块,一个函数,或者一个类来进行正确性检验的测试工作,比如<font color="red"><code>abs()</code></font>这个函数,我们可以传进去1,-1,0,None期待它返回它的绝对值或者是错误信息,把上面的测试放到一个模块里,这个模块就是一个完整的单元测试.</p>
<p>如果这个单元测试能够通过,要么这个函数有bug,要么测试输入条件有bug,总之我们需要修复使单元测试能够通过.</p>
<p>单元测试有意义吗?当然,要不我还在说什么,当你对一个函数或者模块进行修改时,我们只需要再跑一遍测试模块就可以知道我们的修改会不会对原有的模块或函数有影响.然后我们在进行改进.</p>
<p>我们先编写一个<font color="red"><code>Dict</code></font>类,这个类和<font color="red"><code>dict</code></font>一致,但是可以通过属性来访问.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = Dict(a=1, b=2)</span><br><span class="line">&gt;&gt;&gt; d[&apos;a&apos;]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; d.a</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>我么可以这么定义这个Dict类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Dict(dict):</span><br><span class="line"></span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super().__init__(**kw)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(r&quot;&apos;Dict&apos; object has no attribute &apos;%s&apos;&quot; % key)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key] = value</span><br></pre></td></tr></table></figure></p>
<p>我们定义的Dict是根据dict来修改的,那么我们修改之后会影响之前dict的功能吗?这时候我们就写一个单元测试,来test一下是不是有影响.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">from mydict import Dict</span><br><span class="line"></span><br><span class="line">class TestDict(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_init(self):</span><br><span class="line">        d = Dict(a=1, b=&apos;test&apos;)</span><br><span class="line">        self.assertEqual(d.a, 1)</span><br><span class="line">        self.assertEqual(d.b, &apos;test&apos;)</span><br><span class="line">        self.assertTrue(isinstance(d, dict))</span><br><span class="line"></span><br><span class="line">    def test_key(self):</span><br><span class="line">        d = Dict()</span><br><span class="line">        d[&apos;key&apos;] = &apos;value&apos;</span><br><span class="line">        self.assertEqual(d.key, &apos;value&apos;)</span><br><span class="line"></span><br><span class="line">    def test_attr(self):</span><br><span class="line">        d = Dict()</span><br><span class="line">        d.key = &apos;value&apos;</span><br><span class="line">        self.assertTrue(&apos;key&apos; in d)</span><br><span class="line">        self.assertEqual(d[&apos;key&apos;], &apos;value&apos;)</span><br><span class="line"></span><br><span class="line">    def test_keyerror(self):</span><br><span class="line">        d = Dict()</span><br><span class="line">        with self.assertRaises(KeyError):</span><br><span class="line">            value = d[&apos;empty&apos;]</span><br><span class="line"></span><br><span class="line">    def test_attrerror(self):</span><br><span class="line">        d = Dict()</span><br><span class="line">        with self.assertRaises(AttributeError):</span><br><span class="line">            value = d.empty</span><br></pre></td></tr></table></figure></p>
<p>编写单元测试的时候,我们编写的测试类从<font color="red"><code>unittest.TestCase</code></font>继承</p>
<p>必须要以<font color="red"><code>test</code></font>开头的方法才是测试方法,不然测试的时候不会执行.由于<font color="red"><code>unittest.TestCase</code></font>提供了很多内置的判断条件,比如<font color="red"><code>assertEqual()</code></font>来判断是否相等.还有另一种断言就是期待抛出指定类型的Error,我们使用<font color="red"><code>assertRaise</code></font>来实现,比如通过<font color="red"><code>d.[&#39;empty&#39;]</code></font>访问不存在的key时,断言会抛出<font color="red"><code>keyError</code></font>,<code>with self.assertRaises(KeyError):</code></p>
<h3 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h3><p>我们写好单元测试后最好最简单的运行方式是在最后加上两行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>这样,这个测试单元就可以当做脚本运行,另一种方法是通过参数<font color="red"><code>-m unittest</code></font>直接运行:<br><code>python -m unittest mydict_test</code></p>
<h3 id="setUp与setDown"><a href="#setUp与setDown" class="headerlink" title="setUp与setDown"></a>setUp与setDown</h3><p>在单元测试中可以在类中编写两个特殊的方法:<font color="red"><code>setUp()</code></font>和<font color="red"><code>setDown()</code></font>,这两个方法会在每个测试方法之前和之后运行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TestDict(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        print(&apos;setUp...&apos;)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        print(&apos;tearDown...&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="回忆一下装饰器"><a href="#回忆一下装饰器" class="headerlink" title="回忆一下装饰器"></a>回忆一下装饰器</h3><p>使用装饰器对输入的分数进行检查:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#先写装饰器</span><br><span class="line">def checksocre(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        for n in args:</span><br><span class="line">            if not isinstance(n._score, (int,float)):</span><br><span class="line">                raise TypeError(&quot;Score must be integer or float&quot;)</span><br><span class="line">            if n._score &lt; 0 or n._score &gt; 100:</span><br><span class="line">                raise ValueError(&quot;Score must between 0 and 100&quot;)</span><br><span class="line">        return func(*args,**kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line">#定义student类</span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">    self.name = name</span><br><span class="line">    self.score = score</span><br><span class="line"></span><br><span class="line">    @checkinput</span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;= 60 and self.score &lt;80:</span><br><span class="line">            return &apos;B&apos;</span><br><span class="line">        if self.score &gt;= 80:</span><br><span class="line">            return &apos;A&apos;</span><br><span class="line">        return &apos;C&apos;</span><br></pre></td></tr></table></figure></p>
<p>————–最后在写出测试单元:———-</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class TestStudent(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_80_to_100(self):</span><br><span class="line">        s1 = Student(&apos;Bart&apos;, 80)</span><br><span class="line">        s2 = Student(&apos;Lisa&apos;, 100)</span><br><span class="line">        self.assertEqual(s1.get_grade(), &apos;A&apos;)</span><br><span class="line">        self.assertEqual(s2.get_grade(), &apos;A&apos;)</span><br><span class="line"></span><br><span class="line">    def test_60_to_80(self):</span><br><span class="line">        s1 = Student(&apos;Bart&apos;, 60)</span><br><span class="line">        s2 = Student(&apos;Lisa&apos;, 79)</span><br><span class="line">        self.assertEqual(s1.get_grade(), &apos;B&apos;)</span><br><span class="line">        self.assertEqual(s2.get_grade(), &apos;B&apos;)</span><br><span class="line"></span><br><span class="line">    def test_0_to_60(self):</span><br><span class="line">        s1 = Student(&apos;Bart&apos;, 0)</span><br><span class="line">        s2 = Student(&apos;Lisa&apos;, 59)</span><br><span class="line">        self.assertEqual(s1.get_grade(), &apos;C&apos;)</span><br><span class="line">        self.assertEqual(s2.get_grade(), &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">    def test_invalid(self):</span><br><span class="line">        s1 = Student(&apos;Bart&apos;, -1)</span><br><span class="line">        s2 = Student(&apos;Lisa&apos;, 101)</span><br><span class="line">        with self.assertRaises(ValueError):</span><br><span class="line">            s1.get_grade()</span><br><span class="line">        with self.assertRaises(ValueError):</span><br><span class="line">            s2.get_grade()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>如果你有阅读官方文档的习惯,你应该能看到许多dome,比如<code>re模块</code>就带了实例代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; m = re.search(&apos;(?&lt;=abc)def&apos;, &apos;abcdef&apos;)</span><br><span class="line">&gt;&gt;&gt; m.group(0)</span><br><span class="line">&apos;def&apos;</span><br></pre></td></tr></table></figure></p>
<p>这些代码也可以写到注释中让它们自动执行.这时候我们就需要Python内置的”文档测试”(doctest)模块可以提取注释并进行测试,doctest严格按照Python交互命令行的输入和输出来判断测试结果是否正确,只有测试异常时可以使用<font color="red"><code>...</code></font>来略过输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Dict(dict):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Simple dict but also support access as x.y style.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; d1 = Dict()</span><br><span class="line">    &gt;&gt;&gt; d1[&apos;x&apos;] = 100</span><br><span class="line">    &gt;&gt;&gt; d1.x</span><br><span class="line">    100</span><br><span class="line">    &gt;&gt;&gt; d1.y = 200</span><br><span class="line">    &gt;&gt;&gt; d1[&apos;y&apos;]</span><br><span class="line">    200</span><br><span class="line">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&apos;3&apos;)</span><br><span class="line">    &gt;&gt;&gt; d2.c</span><br><span class="line">    &apos;3&apos;</span><br><span class="line">    &gt;&gt;&gt; d2[&apos;empty&apos;]</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    KeyError: &apos;empty&apos;</span><br><span class="line">    &gt;&gt;&gt; d2.empty</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    AttributeError: &apos;Dict&apos; object has no attribute &apos;empty&apos;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super(Dict, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(r&quot;&apos;Dict&apos; object has no attribute &apos;%s&apos;&quot; % key)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure></p>
<p>除了异常描述的第一行和最后一行,异常描述的其余行可以使用三个点<font color="red"><code>...</code></font>表示,<font color="red"><code>&gt;&gt;&gt;</code></font>和命令中间的空格必须有.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/eighth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/eighth/" itemprop="url">小圆第八天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-21T16:57:45+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象的高级编程"><a href="#面向对象的高级编程" class="headerlink" title="面向对象的高级编程"></a>面向对象的高级编程</h1><h2 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h2><p>通常,我们定义一个class并且创建一个实例后,我们可以给该实例绑定任何<font color="red">属性和方法</font>.这就是动态语言的灵活性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br><span class="line">#试着绑定一个实例</span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 动态给实例绑定一个属性</span><br><span class="line">&gt;&gt;&gt; print(s.name)</span><br><span class="line">Michael</span><br></pre></td></tr></table></figure></p>
<p>绑定方法之前没有说,在这里<font color="red"><strong>重点</strong></font>强调一下.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法</span><br><span class="line">...     self.age = age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; from types import MethodType</span><br><span class="line">&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法</span><br><span class="line">&gt;&gt;&gt; s.set_age(25) # 调用实例方法</span><br><span class="line">&gt;&gt;&gt; s.age # 测试结果</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>但是给一个实例绑定的方法对其他实例不起作用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s2 = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;set_age&apos;</span><br></pre></td></tr></table></figure></p>
<p>为了给所有实例都绑定方法,我们可以把这个方法进行class绑定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def set_score(self, score):</span><br><span class="line">...     self.score = score</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Student.set_score = set_score</span><br><span class="line">#也可以使用Student.set_score=MethodType(set_score,Student)</span><br></pre></td></tr></table></figure></p>
<p>这样的话,所有实例都可以调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.set_score(100)</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; s2.set_score(99)</span><br><span class="line">&gt;&gt;&gt; s2.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
<h3 id="使用slots-1"><a href="#使用slots-1" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h3><p>如果我们想要限制实例的属性怎么办?</p>
<p>比如Student实例只要<code>name</code>和<code>age</code>属性,这时我么就可以定义一个特殊的变量<code>__slots__</code>来限制class实例添加的属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br><span class="line">#然后我们test一下</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</span><br><span class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>score</code>没有放到<code>__slots__</code>中,所以不能绑定<code>score</code>属性.使用<code>__slots__</code>要注意,只对当前类的实例起作用,对于继承的子类不起作用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class GraduateStudent(Student):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; g = GraduateStudent()</span><br><span class="line">&gt;&gt;&gt; g.score = 9999</span><br></pre></td></tr></table></figure></p>
<p>除非在子类中也定义<code>__slots__&#39;,这样允许的属性就是自身的</code><strong>slots</strong><code>和父类的</code><strong>slots</strong>`.</p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p> 在绑定属性的时候如果直接把属性暴露出去很简单,但是这样就没办法检查参数是否合法,我们可以通过<code>set_XX()</code>方法来设置属性,<code>get_XX()</code>来得到属性:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">   def get_score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">   def set_score(self, value):</span><br><span class="line">       if not isinstance(value, int):</span><br><span class="line">           raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">       if value &lt; 0 or value &gt; 100:</span><br><span class="line">           raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">       self._score = value  #这样就可以进行参数检查</span><br></pre></td></tr></table></figure></p>
<p>这样就不能随心所欲的设置score了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.set_score(60) # ok!</span><br><span class="line">&gt;&gt;&gt; s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.set_score(9999)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<p>但是每次这么写会很麻烦,你还记得装饰器吗?可以动态给函数增加功能的那个!对于类,Python内置的<code>@property</code>装饰器就是负责把一个<font color="red">方法变成属性</font>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure></p>
<p>把一个getter方法变成属性,只需要加上<font color="red"><code>@property</code></font>就可以了,而另一个装饰器<font color="red"><a href="mailto:`@score.setter" target="_blank" rel="noopener">`@score.setter</a>`</font>,负责把另一个setter方法变成属性赋值,这样我们就可以对属性进行操作啦!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure></p>
<p>在定义只读属性时,只定义getter方法,不定义setter方法就是一个只读属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2015 - self._birth</span><br><span class="line">#为什么要加_，因为你函数名和变量名重复了，_加这个代表一个变量。</span><br><span class="line">#为什么最后加不加_都可以，加_是代表直接调用变量计算，不加_是通过函数值取得变量值计算，相当于get(value)方法</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>birth</code>是可读可写,而<code>age</code>是只读属性</p>
<p>——————–小结——————–</p>
<p><font color="red"><code>@property</code></font>可以让调用者写出简短的代码,同时保证对参数的检查.</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>还记得之前讲过动物之间的继承关系吗?<br>Dog - 狗狗；<br>Bat - 蝙蝠；<br>Parrot - 鹦鹉；<br>Ostrich - 鸵鸟<br>他们都继承于<code>Animal</code>,他们当中有些是哺乳动物,有些是鸟.那么我们可以如下继承:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Bat(Mammal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Parrot(Bird):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Ostrich(Bird):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>现在,我们要给动物加上<font color="red"><code>runnable</code></font>和<font color="red"><code>Flyable</code></font>的功能,只需要定义好<font color="red"><code>runnable</code></font>和<font color="red"><code>Flyable</code></font>的类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Runnable(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Running...&apos;)</span><br><span class="line"></span><br><span class="line">class Flyable(object):</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&apos;Flying...&apos;)</span><br></pre></td></tr></table></figure></p>
<p>对于需要<font color="red"><code>runnable</code></font>功能的动物,就多继承一个<font color="red"><code>runnable</code></font>.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, Runnable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>这样,通过多重继承,一个子类就可以同时获得多个父类的所有功能.</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>其实关于多重继承只要了解拓扑排序就可以很清楚的知道多重继承的查询顺序.从入度为0的位置起,剪掉入度为0相关边,然后接着找下一个入度为0的位置,如此往复到最后,遇到有多个入度为0的时候,按最左原则取就行了.</p>
<p>如果还是不了解请看这篇博客<a href="https://kevinguo.me/2018/01/19/python-topological-sorting/" target="_blank" rel="noopener">Python多重继承之拓扑排序</a></p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>我们已经知道<code>__slots__</code>的用法,以及<code>__len__()</code>也是为了能让class作用于len()函数.除此之外,Python的class中海油很多这样的特殊函数可以帮助我们定制类.</p>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>我们先定义一个<code>Student</code>类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(Student(&apos;Michael&apos;))</span><br><span class="line">&lt;__main__.Student object at 0x109afb190&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样打印一堆<font color="red">&lt;<strong>main</strong>.Student object at 0x109afb190&gt;</font>不好看.</p>
<p>这时我们把定义好的<font color="red"><code>__str__()</code></font>方法,返回一个好看的字符串就可以了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...         return &apos;Student object (name: %s)&apos; % self.name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(Student(&apos;Michael&apos;))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure></p>
<p>你可能会发现直接敲变量而不用<font color="red"><code>print</code></font>打印出来的还是不好看.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;__main__.Student object at 0x109afb310&gt;</span><br></pre></td></tr></table></figure></p>
<p>这时因为直接显示调用的不是<font color="red"><code>__str__()</code></font>,而是<font color="red"><code>__repr__()</code></font>,二者的区别就是<font color="red"><code>__repr__()</code></font>程序开发者看到的字符串,而<font color="red"><code>__str__()</code></font>返回用户看到的字符串.</p>
<p>我们可以定义一个<font color="red"><code>__repr__()</code></font>,但是通常<font color="red"><code>__repr__()</code></font>和<font color="red"><code>__str__()</code></font>代码一样,所以我们可以直接写<code>__repr__ = __str__</code>.</p>
<h2 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h2><p>如果想让一个被用于<font color="red"><code>for ... in</code></font>循环,类似list或者tuple那样,我们可以实现一个<font color="red"><code>__iter__()</code></font>方法,该方法返回一个迭代对象,然后,Python的for循环就会不断调用该迭代对象的<font color="red"><code>__next__()</code></font>方法拿到下一个值,直到<font color="red"><code>StopIteration</code></font>错误时退出循循环.eg如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure></p>
<p>那么,试试把Fib实例作用于for循环:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in Fib():</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">...</span><br><span class="line">46368</span><br><span class="line">75025</span><br></pre></td></tr></table></figure></p>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a>__getitem__</h3><p>Fib实例虽然能作用于for循环,看起来和list有点像,但是把它当做list还是不行,比如取第五个元素list[5]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Fib()[5]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;Fib&apos; object does not support indexing</span><br></pre></td></tr></table></figure></p>
<p>要表现的像list那样按照下标取出元素需要实现<font color="red"><code>__getitem__()</code></font>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        a, b = 1, 1</span><br><span class="line">        for x in range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        return a</span><br><span class="line">#测试是否可行</span><br><span class="line">&gt;&gt;&gt; f = Fib()</span><br><span class="line">&gt;&gt;&gt; f[0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f[1]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f[2]</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; f[10]</span><br><span class="line">89</span><br></pre></td></tr></table></figure></p>
<p>但是别忘了list还有切片功能,但是Fib却报错.说明它还是不太像list.至于为什么报错呢?</p>
<p>原因是<font color="red"><code>__getitem__()</code></font>传入的参数可能是一个int,也可能是一个切片的对象,所以在这里要进行判断:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start = 0</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            L = []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return L</span><br></pre></td></tr></table></figure></p>
<p>那么现在让我们试试Fib的切片:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = Fib()</span><br><span class="line">&gt;&gt;&gt; f[0:5]</span><br><span class="line">[1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; f[:10]</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure></p>
<p>是不是这样都完美了?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实你想多了…你看看这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f[:10:2]</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure></p>
<p>我们没有对step处理,也没有对负数处理,所以要正确实现一个<font color="red"><code>__getitem__()</code></font>还有很多工作要做,而做这行工作的过程就是定制你想要的类的过程.此外如果把对象看成<font color="red"><code>dict</code></font>,<font color="red"><code>__getitem__()</code></font>的参数也可能是一个可以做key的object.与之对应的是<font color="red"><code>__setitem__()</code></font>方法,把对象视作list或dic来对集合赋值,还有<font color="red"><code>__delitem__()</code></font>方法用来删除某个元素.</p>
<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h3><p>正常情况下我们调用类里不存在的方法或者属性的时候,会报错,那么我们如何避免这个问题?</p>
<p>除了在类中加上<font color="red"><code>score</code></font>这个属性外,我们还可以写一个<font color="red"><code>__getattr__()</code></font>方法,动态返回一个属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;Michael&apos;</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;score&apos;:</span><br><span class="line">            return 99</span><br></pre></td></tr></table></figure></p>
<p>当调用不存在的属性时:Python会试图调用<font color="red"><code>__getattr__(self,&#39;score&#39;)</code></font>来尝试获得属性,这样我们就有机会返回<font color="red"><code>score</code></font>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.name</span><br><span class="line">&apos;Michael&apos;</span><br><span class="line">&gt;&gt;&gt; s.score #注意,只是返回这个值,但其实score这个属性并没有在s里</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
<p>我们用来返回函数也是可以的,只不过调用方式要改变一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;age&apos;:</span><br><span class="line">            return lambda: 25</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s.age()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>注意,只有在没有找到属性的情况下才调用<font color="red"><code>__getattr__</code></font>,已有的属性比如<font color="red"><code>name</code></font>,不会在<font color="red"><code>__getattr__()</code></font>中查找</p>
<p>此外,任意调用如<font color="red"><code>s.abc</code></font>都会返回<font color="red"><code>None</code></font>,这是因为我们定义的<font color="red"><code>__getattr__</code></font>默认返回就是<font color="red"><code>None</code></font>,要使class只响应特定的几个属性,我们可以按照约定抛出<font color="red"><code>AttributeError</code></font>的错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;age&apos;:</span><br><span class="line">            return lambda: 25</span><br><span class="line">        raise AttributeError(&apos;\&apos;Student\&apos; object has no attribute \&apos;%s\&apos;&apos; % attr)</span><br></pre></td></tr></table></figure></p>
<p>这就把一个类的所有属性和方法全部动态化处理了,不需要任何特殊手段.这样就可以支持完全动态的情况做调用,举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</span><br><span class="line">&apos;/status/user/timeline/list&apos;</span><br></pre></td></tr></table></figure>
<p>这样无论怎么变都可以实现完全动态调用,不随参数的增加而改变,有时候我们还会把参数写进来比如:<code>GET /users/:user/repos</code>,在调用时把<font color="red"><code>:user</code></font>替换为实际用户名<code>Chain().users(&#39;michael&#39;).repos</code>.</p>
<p>具体怎么写等我们看完下面的方法后在说QAQ</p>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><p>一个对象实例有自己的属性和方法,我们可以调用这是属性和方法,那么实例本身可不可以调用呢?</p>
<p>当然可以啦!要不这么多废话干嘛.具体方法就是要定义一个<font color="red"><code>__call__()</code></font>就可以直接对实例进行调用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;My name is %s.&apos; % self.name)</span><br><span class="line">    #调用方式如下:</span><br><span class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</span><br><span class="line">&gt;&gt;&gt; s() # self参数不要传入</span><br><span class="line">My name is Michael.</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>__call__()</code></font>还可以定义参数.对视力进行直接调用就像对函数进行调用一样,所以函数和对象就没啥区别.</p>
<p>那么我们如何判断一个变量是对象还是函数呢?其实,我们判断一个对象能否被调用就知道是不是一个<font color="red"><code>Callable</code></font>对象,比如函数和上面定义的带有<font color="red"><code>__call__()</code></font>的类.举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; callable(Student())</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable(max)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable([1, 2, 3])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(None)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<h3 id="关于完全动态调用的栗子以及解释"><a href="#关于完全动态调用的栗子以及解释" class="headerlink" title="关于完全动态调用的栗子以及解释"></a>关于完全动态调用的栗子以及解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>
<p>Chain().status.user.timeline.list “敲回车键”</p>
<p>“()”和“.”和“回车键”都是从左向右的顺序运算符，类比成数学中的加和减。</p>
<p>步骤：<br>1、Chain是类名，对它进行“()”运算，即调用<strong>init</strong>(self)(这个有讲过哦),会生成一个实例c1，c1=Chain(path=’’)。</p>
<p>2、对实例c1进行“.”运算，增加一个“status”属性，即调用<strong>getattr</strong>(self, status),返回一个新实例c2,c2=Chain(path=’/status’)。</p>
<p>3、对实例c2进行“.”运算，增加一个“user”属性，即调用<strong>getattr</strong>(self, user),返回一个新实例c3,c3=Chain(path=’/status/user’)。</p>
<p>4、对实例c3进行“.”运算，增加一个“timeline”属性，即调用<strong>getattr</strong>(self, timeline),返回一个新实例c4,c4=Chain(path=’/status/user/timeline’)。</p>
<p>5、对实例c4进行“.”运算，增加一个“list”属性，即调用<strong>getattr</strong>(self, list),返回一个新实例c5,c5=Chain(path=’/status/user/timeline/list’)。</p>
<p>6、对实例c5进行“回车键”运算，即调用<strong>repr</strong>(self)，返回c5._path,即输出’/status/user/timeline/list’。</p>
<p>这样再来看思考题：Chain().users(‘michael’).repos就很清晰了。<br>Chain–“()”(即调用<strong>init</strong>)——&gt;c1——“.users”(即调用<strong>getattr</strong>)——&gt;c2——“(‘michael’)”(即调用<strong>call</strong>)——&gt;c3——“.repos”(即调用<strong>getattr</strong>)——&gt;c4——“回车键”(即调用<strong>repr</strong>)——&gt;’/users/michael/repos’。</p>
<p>那么类该怎么写，就不用多说了吧。只比老师的示例多加一个<strong>call</strong>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __call__(self, param):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, param))</span><br></pre></td></tr></table></figure></p>
<h2 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h2><p>当我们需要定义大量的常量时我们可以使用枚举类型,Python提供了<font color="red"><code>Enum</code></font>类来实现这个功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接引用<font color="red"><code>Month.jan</code></font>来引用一个常量,或者枚举它的所有成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():#特别注意是__member__</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>value</code></font>属性是自动赋给成员的int常量,默认从<font color="red">1</font>开始计数.</p>
<p>接下来的例子要仔细看,其实发现枚举的控制很方便.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique #装饰器可以帮助我们检查保证没有重复值</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure></p>
<p>接下来的访问有很多种方法…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; day1 = Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1 == Weekday(1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Weekday(7)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: 7 is not a valid Weekday</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &apos;=&gt;&apos;, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/seventh/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/seventh/" itemprop="url">小圆第七天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T21:08:20+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>————-模块的好处————-</p>
<p>最大的好处是大大提高了代码的可维护性,使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中,但是也要注意，尽量不要与内置函数名字冲突.</p>
<p>你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package).</p>
<p>假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mycompany</span><br><span class="line">├─ \_\_init\_\_.py</span><br><span class="line">├─ abc.py</span><br><span class="line">└─ xyz.py</span><br></pre></td></tr></table></figure></p>
<p>现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p>
<p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是mycompany。</p>
<p>—————-小结一下————-</p>
<p>1、每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p>
<p>2、init.py可以是空文件，也可以有Python代码，因为init.py本身就是一个模块；</p>
<p>3、模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</p>
<p>4、模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</p>
<p>5、内置函数解释地址：<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a></p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身内置很多有用的模块,可以直接使用eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  #注释,加上后可以直接在Unix/Linux/Mac上运行</span><br><span class="line"># -*- coding: utf-8 -*- #注释,表示.py本身使用标准UTF-8编码</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;  #任何模块代码的第一个字符串都被视为文档注释;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;  #作者姓名..</span><br><span class="line"></span><br><span class="line">import sys  #导入模块</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv  #模块内的argv变量,用list存储命令行的所有参数,至少有一个元素(该.py文件的名称)</span><br><span class="line">    #例如:运行python3 hello.py jialiaoyuan获得的sys.argv就是[&apos;hello.py&apos;,&apos;jialiaoyuan&apos;].</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&apos;Hello, world!&apos;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&apos;Hello, %s!&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test() #如果在其他地方导入这个模块,if判断失败,不执行test(),用来测试使用</span><br></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>和类c语言类似,有时候我们不想让一些变量或函数暴露出来,所以可以添加私有变量,在python中通过<code>_</code>前缀来实现.</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途,类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用,之所以说”不应该”是应为Python编辑器<font color="red">拦不住</font>你想访问,我们在编程习惯上不应该引用private函数或变量.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def _private_1(name):</span><br><span class="line">    return &apos;Hello, %s&apos; % name</span><br><span class="line"></span><br><span class="line">def _private_2(name):</span><br><span class="line">    return &apos;Hi, %s&apos; % name</span><br><span class="line"></span><br><span class="line">def greeting(name):</span><br><span class="line">    if len(name) &gt; 3:</span><br><span class="line">        return _private_1(name)</span><br><span class="line">    else:</span><br><span class="line">        return _private_2(name)</span><br></pre></td></tr></table></figure></p>
<p>通过这种方法,我们公开<code>greeting()</code>函数,而内部的private函数隐藏,这样就不用关注细节,只用来提供接口就可以.</p>
<h1 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h1><p>面向对象编程—-Object Oriented Programming,简称OOP,OOP把对象作为程序的基本单元.一个对象包含了数据和操作数据的函数.</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>接下来copy了一个非常有意思的评论,加深理解类.<br>上帝</p>
<p>class 类 (人)<br>instance 实例 (你,我,他)<br>你会有些属性(身高,年龄,体重)<br>你会有些技能(吃饭,泡妞)</p>
<p><code>__init__</code> 方法的主要作用,就是初始化你的属性,这些属性,在上帝初始化你的时候就要赋予给你,比如<code>zhangsan = Person(170,29,50)`</code>这时上帝就把你创造出来了，也就是实例化了你，然后，你到底有哪些技能呢，这就看有没有在类里面定义了，如果有定义泡妞的技能，那么你就可以调用泡妞的技能来泡妞，大致就是这样吧，看看下面的例子就更清楚了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"># 这里就是初始化你将要创建的实例的属性</span><br><span class="line">    def __init__(self,hight,weight,age):</span><br><span class="line">        self.hight = hight</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"># 定义你将要创建的实例所有用的技能</span><br><span class="line">    def paoniu(self):</span><br><span class="line">        print(&apos;你拥有泡妞的技能&apos;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;you can eat&apos;)</span><br><span class="line"></span><br><span class="line"># 开始创建实例</span><br><span class="line">zhangsan=Person(170,50,29)</span><br><span class="line">lisi = Person(175,100,30)</span><br><span class="line"></span><br><span class="line"># 你的实例开始使用它的技能</span><br><span class="line">zhangsan.paoniu()</span><br><span class="line">lisi.eat()</span><br></pre></td></tr></table></figure></p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象中最重要的就是类和实例,类是抽象的模板,而实例是根据类创建出来的一个个具体的”对象”.让我们先定义一个空类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>class后面紧跟的是类名,即Student,类名通常开头字母大写,紧接着是<code>(object)</code>,表示该类是从哪继承的,也可以不写,默认继承<code>object</code>类,这是所有的类最终都会继承的类.创建实例是通过类名+()实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>bart</code>指向的是<code>Student</code>的实例,后面跟着内存地址,而Student本身则是一个类.</p>
<p>可以自由的给给一个变量绑定属性,比如给<code>bart</code>绑定了一个<code>name</code>属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.name = &apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以在创建实例的时候,把必须绑定的属性强制添进去,通过<code>__init__</code>方法就可以把<code>name</code>,<code>score</code>等属性绑上去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure></p>
<p>注意<code>__init__</code>第一个参数永远是<code>self</code>,表示实例本身,如果类中有了<code>__init__</code>,在创建实例的时候,就不能传入空的参数,<font color="red">必须</font>传入与<code>__init__</code>方法匹配的参数,但是<code>self</code>实例本身不需要传.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure></p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>面对对象编程的一个重要的特点就是数据封装.在上面的<code>Student</code>类中,每个实例都有name,score这些数据,我们可以通过函数访问这些数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_score(std):</span><br><span class="line">...     print(&apos;%s: %s&apos; % (std.name, std.score))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_score(bart)</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure></p>
<p>但是,既然Student实例本身都有这些数据,那么我们为什么要在外边定义函数访问呢?我们可以在内部定义这些函数,谁调用我们自己处理就好了,这就把数据’封装’起来了,我们称之为类的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.name, self.score))</span><br><span class="line">    #调用如下</span><br><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure></p>
<p>我们还可以给Student类添加新的方法,比如<code>get_grade</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;= 90:</span><br><span class="line">            return &apos;A&apos;</span><br><span class="line">        elif self.score &gt;= 60:</span><br><span class="line">            return &apos;B&apos;</span><br><span class="line">        else:</span><br><span class="line">            return &apos;C&apos;</span><br><span class="line">    #调用如下</span><br><span class="line">&gt;&gt;&gt;bart.get_grade()</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>前面刚刚介绍了类和对象可以隐藏内部的复杂逻辑.但是之前好像又说到可以自由的修改一个实例的<code>name</code>,<code>score</code>属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; bart.score = 99</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
<p>如果想让内部属性不能呗外部访问,可以把属性名称前面加上两个<code>__</code>,这样就变成了私有变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.__name, self.__score))</span><br><span class="line">        #改完后测试一波</span><br><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们还想访问和改变怎么办?</p>
<p>这时候我们就可以给类增加<code>get_score</code>和<code>get_name</code>以及<code>set_score</code>这样的方法,通过内部的方法来访问,返回内部的值.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&apos;bad score&apos;)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是: 在python中类似<code>__xxx__</code>这样的变量名是特殊变量,可以直接访问,所以不能用<code>__name__</code>,<code>__score__</code>这样的变量名.</p>
<p>有时候你会看到一个下划线开头的变量名比如<code>_name</code>这样的变量是可以从外部访问的,但是按照约定,你看到这样的变量就是说”我虽然可以访问,但是,请你把我看做私有变量”</p>
<p>那么双下划线一定不能访问吗?</p>
<p>其实也不是.不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<p>但是强烈不建议你这么做,因为不同的python为把<code>__name</code>改成不同的名字,总的来说python本身不阻止你做坏事,一切靠自觉.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.get_name()</span><br><span class="line">&apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">&apos;New Name&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面这种写法表面是’成功’的设置了<code>__name</code>变量,但实际上这个<code>__name</code>变量和class内部的<code>__name__</code>不是一个变量!这时外部仅仅给<code>bart</code>增加了一个新的<code>__name</code>变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>在OPP程序设计中,当我们定义一个class的时候,可以从现在有的class,新的class称为子类,被继承的class称为基类,父类,或者超类.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#首先写一个父类</span><br><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Animal is running...&apos;)</span><br><span class="line">#再写两个子类</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>对于<code>Dog</code>来说,<code>Animmal</code>是它的父类,对于<code>Animal</code>来说,<code>Dog</code>就是它的子类.</p>
<p>那么继承有啥好处?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br><span class="line">#结果如下:</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure></p>
<p>可以看到子类获得父类的全部功能,<code>Dog</code>和<code>Cat</code>什么都没做就自动拥有了<code>run()</code>.</p>
<p>当然我们也可以对子类添加一些方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Dog is running...&apos;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;Eating meat...&apos;)</span><br><span class="line">#再次运行</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line">Dog is running..</span><br></pre></td></tr></table></figure></p>
<p>当子类和父类存在相同的方法时比如<code>run()</code>,子类的<code>run()</code>覆盖父类的<code>run()</code>,所以总是调用子类的<code>run()</code>,这样我们就获得了继承的另一个好处:<font color="red">多态</font></p>
<p>要理解多态,我们要先明白当我们定义一个class时就是定义一个数据类型,和str,list,dict没什么区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = list() # a是list类型</span><br><span class="line">b = Animal() # b是Animal类型</span><br><span class="line">c = Dog() # c是Dog类型</span><br><span class="line">&gt;&gt;&gt; isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Dog)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>最后一个例子可以看出c不仅仅是<code>Dog</code>,c还是<code>Animal</code>!,但是反过来就不可以!</p>
<p>要理解多态的好处还是要通过示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line">#这时我们传入Animal的实例:</span><br><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br><span class="line">#传入Dog的实例:</span><br><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure></p>
<p>看上去好像没啥意思,但是我们再定义一个<code>Tortoise</code>类型,也从<code>Animal</code>派生:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Tortoise is running slowly...&apos;)</span><br><span class="line">#实现调用:</span><br><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure></p>
<p>你会发现多态的好处就是当我们传入<code>Dog</code>,<code>Cat</code>,<code>Tortoise</code>….时,我们只需要接受<code>Animal</code>类型就可以了,因为它们都是<code>Animal</code>类型,按照<code>Animal</code>类型操作就可以了,这就是多态的意思,调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则</p>
<h3 id="静态语言VS动态语言"><a href="#静态语言VS动态语言" class="headerlink" title="静态语言VS动态语言"></a>静态语言VS动态语言</h3><p>对于静态语言(java,c++),如果需要传入<code>Animal</code>类型,则传入的对象必须是<code>Animal</code>类型或者它的子类,否则不能调用<code>run()</code>,而对于Python这样的动态语言,只需要保证传入的对象有一个<code>run()</code>方法就可以了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Start...&apos;)</span><br><span class="line">#对它进行调用</span><br><span class="line">&gt;&gt;&gt; run_twice(Timer())</span><br><span class="line">Start...</span><br><span class="line">Start...</span><br></pre></td></tr></table></figure></p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象.</p>
<p>也可以这么说:python不限制参数类型，那任何对象都可以传入，只要它有需要调用的方法，代码都可以顺利运行。另一方面，即使传入的对象继承了理想中的对象，也不能保证该对象还具有需要调用的方法，因为我甚至可以在对象里把从父类继承的方法变成None,所以一切靠自觉遵守规则.</p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>当我们拿到一个对应的引用时,我们如何才能知道对象是什么类型,有哪些方法呢?</p>
<h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p>首先,我们来判断对象的类型,使用<code>type()</code>函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&apos;str&apos;)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;type(None) &apos;NoneType&apos;&gt;</span><br><span class="line">#如果一个变量指向一个函数或者类:</span><br><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;__main__.Animal&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>type()函数返回的是对应的class类型,我们可以加上if判断来比较两个变量的type是否相同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)==type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123)==int</span><br><span class="line">True</span><br><span class="line">#如果要判断一个对象是否是函数,可以使用tpyes模块中定义的常量:</span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType #使用FunctionType也可以</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说<code>type()</code>就显得不是很方便,所以就有了<code>isinstance()</code>函数.<br><code>#假设继承关系:object -&gt; Animal -&gt; Dog -&gt; Husky</code><br>那么可以用<code>isinstance()</code>来判断对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Animal()</span><br><span class="line">&gt;&gt;&gt; d = Dog()</span><br><span class="line">&gt;&gt;&gt; h = Husky()</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Husky)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><code>h</code>虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型,也就是说<code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上.<br>能用<code>type()</code>判断的基本类型也可以用<code>isinstan()</code>判断,并且可以判断一个变量是否是某些变量的一种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(b&apos;a&apos;, bytes)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><font color="red">总是优先使用<code>isinstance()</code>判断类型,可以将制定类型及其子类”一网打尽”</font></p>
<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>如果要获得一个对象的所有属性和方法,可以使用<code>dir()</code>函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure></p>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<code>__len__</code>()方法，所以，下面的代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;len(&apos;abc&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;&apos;abc&apos;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>仅仅知道对象的属性和方法是不够的,我们配合<code>getattr()</code>(获取属性),<code>setattr()</code>(设置属性),以及<code>hasattr()</code>(判断属性),我们可以直接操作一个对象的状态.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#首先让我们先定义一个类:</span><br><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br><span class="line">#然后我们测试属性</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br></pre></td></tr></table></figure></p>
<p>如果试图获取不存在的属性,会抛出AttributeError的错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;) # 获取属性&apos;z&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;MyObject&apos; object has no attribute &apos;z&apos;</span><br><span class="line">#可以传入一个default参数,如果属性不存在就返回默认值:</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure></p>
<p>———–小结一下————</p>
<p>只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：<code>sum = obj.x + obj.y</code>,就不要使用<code>getattr</code><br>以上获取对象信息我们什么时候会用到呢?<br>下面代码<font color="red">很重要</font>.多思考…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 首先你有一个command.py文件，内容如下，这里我们假若它后面还有100个方法</span><br><span class="line"></span><br><span class="line">class MyObject(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 9</span><br><span class="line">    def add(self):</span><br><span class="line">        return self.x + self.x</span><br><span class="line"></span><br><span class="line">    def pow(self):</span><br><span class="line">        return self.x * self.x</span><br><span class="line"></span><br><span class="line">    def sub(self):</span><br><span class="line">        return self.x - self.x</span><br><span class="line"></span><br><span class="line">    def div(self):</span><br><span class="line">        return self.x / self.x</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 然后我们有一个入口文件 exec.py，要根据用户的输入来执行后端的操作</span><br><span class="line">from command import MyObject</span><br><span class="line">computer=MyObject()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    inp = input(&apos;method&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    if inp == &apos;add&apos;:</span><br><span class="line">        computer.add()</span><br><span class="line">    elif inp == &apos;sub&apos;:</span><br><span class="line">        computer.sub()</span><br><span class="line">    elif inp == &apos;div&apos;:</span><br><span class="line">        computer.div()</span><br><span class="line">    elif inp == &apos;pow&apos;:</span><br><span class="line">        computer.pow()</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;404&apos;)</span><br></pre></td></tr></table></figure>
<p>上面使用了if来判断,如果真有100个那么我们总不能写100次判断吧!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from command import MyObject</span><br><span class="line"></span><br><span class="line">computer=MyObject()</span><br><span class="line">def run(x):</span><br><span class="line">    inp = input(&apos;method&gt;&apos;)</span><br><span class="line">    # 判断是否有这个属性</span><br><span class="line">    if hasattr(computer,inp):</span><br><span class="line">    # 有就获取然后赋值给新的变量</span><br><span class="line">        func = getattr(computer,inp)</span><br><span class="line">        print(func())</span><br><span class="line">    else:</span><br><span class="line">    # 没有我们来set一个</span><br><span class="line">        setattr(computer,inp,lambda x:x+1)</span><br><span class="line">        func = getattr(computer,inp)</span><br><span class="line">        print(func(x))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    run(10)</span><br></pre></td></tr></table></figure></p>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>之前我们就已经知道给一个实例绑定属性的方法是通过实例变量,或者通过<code>self</code>变量,但是如果<code>Student</code>类本身需要绑定一个属性呢?可以直接在class中定义属性,这种属性是类属性,归<code>Student</code>所有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;#虽然归类所有,但是类的所有实例都可以访问</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p>
<p>———–小练习—————-</p>
<p>为了统计学生人数,每增加一个类属性,每创建一个实例,该属性自动增加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    count = 0</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count+=1</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/sixth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sixth/" itemprop="url">小圆第六天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T17:43:38+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的.<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<hr>
<p>小结一下:<br>面向对象：一个有诸多技能的工人，可以让这个工人去干很多事情</p>
<p>函数式编程：一群只有单个技能的工人，可以让他们同时出动去干一件复杂的事情</p>
<p>高阶函数：一个工人必须依靠下一个工人的技能才能完成工作</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>告诫函数除了可以接受函数作为参数外,还可以将函数作为结果返回.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>当我们调用lazy_sum()时返回的并不是结果,而是一个函数,当我们不需要立即求和,而是根据需要再来计算,就可以使用这种方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中,外部函数定义了内部函数sum,当外部函数返回sum时,相关参数和变量都保存在返回的函数中,这种结构我们称为闭包.请注意当我们调用lazy_sum()时,每次都会返回一个新的函数,即使传入一个新的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f1==f2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>我们还需要注意另一个问题,返回的函数没有立刻执行,而是直到调用f()才执行.栗子如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p>
<p>#你可能认为调用f1(),f2(),f3()的结果应该是1,4,9,那么实际上呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>全部都是9!因为返回的函数使用了变量i,但上边也说过返回的函数不是立刻执行,等到3个函数都返回时,它所引用的i已经变为3,所以最后都是9.<br><code>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</code></p>
<p>如果一定要引用循环怎么办?不怕,我们可以在创建一个函数,让这个函数的参数来绑定循环变量,无论循环变量怎么改,绑定到函数参数的值不变:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure></p>
<p>——–让我们再看看其他关于闭包的解释——-<br>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#闭包函数的实例</span><br><span class="line"># outer是外部函数 a和b都是外函数的临时变量</span><br><span class="line">def outer( a ):</span><br><span class="line">    b = 10</span><br><span class="line">    # inner是内函数</span><br><span class="line">    def inner():</span><br><span class="line">        #在内函数中 用到了外函数的临时变量</span><br><span class="line">        print(a+b)</span><br><span class="line">    # 外函数的返回值是内函数的引用</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 在这里我们调用外函数传入参数5</span><br><span class="line">    #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span><br><span class="line">    # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span><br><span class="line">    demo = outer(5)</span><br><span class="line">    # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span><br><span class="line">    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span><br><span class="line">    demo() # 15</span><br><span class="line"></span><br><span class="line">    demo2 = outer(7)</span><br><span class="line">    demo2()#17</span><br></pre></td></tr></table></figure></p>
<p>在基本的python语法中,一个函数可以随意读取全局数据,但是要修改的时候有两种方法:<font color="red">:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改.</font>:<br>1 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</p>
<p>　　　　2 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#修改闭包变量的实例</span><br><span class="line"># outer是外部函数 a和b都是外函数的临时变量</span><br><span class="line">def outer( a ):</span><br><span class="line">    b = 10  # a和b都是闭包变量</span><br><span class="line">    c = [a] #这里对应修改闭包变量的方法2</span><br><span class="line">    # inner是内函数</span><br><span class="line">    def inner():</span><br><span class="line">        #内函数中想修改闭包变量</span><br><span class="line">        # 方法1 nonlocal关键字声明,也可以使用global方法,内层和外层都要声明</span><br><span class="line">        nonlocal  b</span><br><span class="line">        b+=1</span><br><span class="line">        # 方法二，把闭包变量修改成可变数据类型 比如列表</span><br><span class="line">        c[0] += 1</span><br><span class="line">        print(c[0])</span><br><span class="line">        print(b)</span><br><span class="line">    # 外函数的返回值是内函数的引用</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    demo = outer(5)</span><br><span class="line">    demo() # 6  11</span><br></pre></td></tr></table></figure></p>
<p>还有一点要注意:使用闭包的过程中,一旦外函数被调用了一次返回了内函数的引用,虽然每次调用内函数,是开启一个函数执行过后消亡,但是闭包变量实际只有一份,每次开启内函数都是在使用同一份闭包变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">def outer(x):</span><br><span class="line">    def inner(y):</span><br><span class="line">        nonlocal x</span><br><span class="line">        x+=y</span><br><span class="line">        return x</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = outer(10)</span><br><span class="line">print(a(1)) #11</span><br><span class="line">print(a(3)) #14</span><br></pre></td></tr></table></figure></p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>之前没有看这章教程的时候就百度过匿名函数的用法,这次终于找到机会把它补全:</p>
<p>匿名函数存在的意义:当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">----lambda x: x*x相当于----</span><br><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure></p>
<p>关键字<font color="red">lambda</font>表示匿名函数,冒号前面的x表示函数参数.</p>
<p>匿名函数有一定的限制,就是只能有一个表达式,返回值就是表达式的结果.但也有优点:不必担心函数名冲突,匿名函数是一个变量,也可以赋值给另一个变量,再利用该变量调用函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>函数对象有一个<strong>name</strong>属性,可以拿到函数的名字:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     print(&apos;2018-11-19&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = now</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">2015-3-25</span><br><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;now&apos;</span><br><span class="line">&gt;&gt;&gt; f.__name__</span><br><span class="line">&apos;now&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在,我们想让now()函数不仅仅打印现在的时间,而是想加一点功能,但是又不希望改变now()函数的定义,在这种代码运行期间动态增加功能的方式我们称为<font color="red">装饰器</font>.</p>
<p>本质上,decorator是一个<font color="red">返回函数</font>的高阶函数,我们可以如下定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-11-19&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面的log函数接受一个函数做参数,返回一个函数.然后通过@语法,把decorator置于函数的定义处,让我们来看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">2018-11-19</span><br></pre></td></tr></table></figure></p>
<p>把<font color="red">@log</font>放到<font color="red">now()</font>函数的定义处相当于执行了语句:<code>now = log(now)</code>由于log()是一个decorator,返回一个函数,所以原来的<font color="red">now()</font>仍然存在,只是现在同名的now()指向了新的函数,条用新函数,即在<font color="red">log()</font>函数中返回的wrapper()函数.</p>
<p><font color="red">wrapper()</font>函数的参数定义是<font color="red">(*args,**kw)</font>,因此,<font color="red">wrapper()</font>函数可以接受任意参数的调用.</p>
<p>如果decorator本身要传入参数,那么我们需要写一个返回decorator的高阶函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-11-19&apos;)</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">execute now():</span><br><span class="line">2018-11-19</span><br></pre></td></tr></table></figure></p>
<p>和两套嵌套相比,三层嵌套本质是这样<code>&gt;&gt;&gt; now = log(&#39;execute&#39;)(now)</code></p>
<p>以上两种decorator的定义都没有问题，但还差最后一步.使用<strong>name</strong>来查看now函数的名称发现它不再是now,而是变成了wrapper:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;wrapper&apos;</span><br></pre></td></tr></table></figure></p>
<p>因为返回的那个<font color="red">wrapper()</font>函数的名字就是<font color="red">‘wrapper’</font>,所以我们需要把原始的<strong>name</strong>等属性赋值到<font color="red">wrapper</font>函数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure></p>
<p>这样now().<strong>name</strong>就变成now了,置于import functools是导入模块,以后再讲,现在就是在<font color="red">wrapper()</font>函数上加入<font color="red">@functools.wraps(func)</font>就可以了.</p>
<p>—接下来做一个小练习—</p>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import time, functools</span><br><span class="line">def metric(fn):</span><br><span class="line">    @functools.wraps(fn)</span><br><span class="line">    def costtime(*args,**kw):</span><br><span class="line">        start=time.time()</span><br><span class="line">        s=fn(*args,**kw)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&apos;%s executed in %s ms&apos; % (fn.__name__, end-start))</span><br><span class="line">        return s</span><br><span class="line">    return costtime</span><br><span class="line"># 测试</span><br><span class="line">@metric</span><br><span class="line">def fast(x, y):</span><br><span class="line">    time.sleep(0.0012)</span><br><span class="line">    return x + y;</span><br></pre></td></tr></table></figure></p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>Python的functools模块提供很多有用的功能,其中一个就是偏函数,在介绍函数参数的时候我们讲到,通过设定函数的默认值可以降低调用的难度,巧了,偏函数也可以.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;)</span><br><span class="line">12345 #默认把字符串转化为整数(10进制)</span><br></pre></td></tr></table></figure></p>
<p><font color="red">int()</font>函数还提供额外的base参数,默认值为10.传入其它的可以做N进制转换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;, base=8)</span><br><span class="line">5349</span><br><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;, 16)</span><br><span class="line">74565</span><br></pre></td></tr></table></figure></p>
<p>当我们有大量的二进制字符串需要转换,每次写int(x,base=2)你乐意吗?我肯定不这么写,所以我们之前可以想到定义一个函数,把默认<font color="red">base=2</font>传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def int2(x,base=2):</span><br><span class="line">    return int(x,base)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p>
<p>这样是不是简单多啦!functools就是帮助我们创建一个偏函数,不需要我们自己定义int2():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1010101&apos;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure></p>
<p>所以简答总结,偏函数的作用就是让函数的某些参数固定住,返回一个新函数.</p>
<p>最后,创建一个偏函数的时候可以接受函数对象,*args,**kw这三个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=2)</span><br><span class="line">#实际上固定int()函数的base相当于</span><br><span class="line">kw=&#123;&apos;base&apos;:2&#125;</span><br><span class="line">int(&apos;10010&apos;,**kw)</span><br></pre></td></tr></table></figure></p>
<p>当传入:<code>max2 = functools.partial(max, 10)</code><br>实际上会把10作为*args的一部分自动加到左边,也就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br><span class="line">#相当于</span><br><span class="line">args = (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/fifth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fifth/" itemprop="url">小圆第五天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T22:39:11+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的.<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<hr>
<p>小结一下:<br>面向对象：一个有诸多技能的工人，可以让这个工人去干很多事情</p>
<p>函数式编程：一群只有单个技能的工人，可以让他们同时出动去干一件复杂的事情</p>
<p>高阶函数：一个工人必须依靠下一个工人的技能才能完成工作</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>变量可以指向函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f(-10)</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>说明变量f现在已经指向了abs所指向的函数,现在调用f()和abs()完全相同</p>
<p>函数名也是变量:</p>
<p>对于abs()这个函数,完全可以把函数看做变量,它指向一个可以计算绝对值的函数!如果把abs指向其他对象,会怎么样?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs = 10</span><br><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;int&apos; object is not callable</span><br></pre></td></tr></table></figure></p>
<p>注:abs函数实际在import builtins模块中,所以要让让abs在其他模块也生效,要用<font color="red">import builtins; builtins.abs = 10</font>.</p>
<p>传入函数:<br>既然变量可以指向函数,函数的参数能接受变量,那么一个函数就可以接受另一个函数作为参数,这种函数就称为高阶函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br><span class="line">------调用如下------</span><br><span class="line">print(add(-5,6,abs))</span><br><span class="line">11</span><br></pre></td></tr></table></figure></p>
<p>在看评论时有一个有意思的东西来记录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max, min = min, max</span><br><span class="line"></span><br><span class="line">print(max(1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure></p>
<p>函数赋值的时候,在赋值之前min,max都已经确定了,这里右边为一个tuple,并不会因为将max值赋为min而改变.</p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>我们先来看map(),map接受两个参数,一个是函数,一个是<font color="red">Iterable</font>,map将传入的函数依次作用到序列的每个元素,并把结果作为新的<font color="red">Iterator</font>返回:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure></p>
<p>因为返回的是Iterator,Iterator是惰性序列,所以要通过list()函数将整个序列都计算出来返回一个list.</p>
<p>你可能会想,不需要map(),我用循环也能写出来…:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:</span><br><span class="line">    L.append(f(n))</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure></p>
<p>确实可以,但是你可能看不出来’把f(x)作用在list的每一个元素并把结果返回一个新的list</p>
<p>所以map()作为告诫函数,事实上把运算规则抽象了,你还可以计算任意复杂的函数,比如转化为字符串,转化为绝对值…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</span><br><span class="line">-----------------------</span><br><span class="line">&gt;&gt;&gt; list(map(abs,[1,-2,3,4,-5,,6,7,-8,-9]))</span><br><span class="line">[1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></p>
<p>再看看reduce的用法:<br>reduce把一个函数作用在[X1,X2,X3,…]上这个函数必须接收<font color="red">两个</font>参数,reduce把结果继续和序列的下一个元素做积累计算,效果就是:<br><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code><br>举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<p>这个栗子本身没啥意思,但是下面就开始热身了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def char2num(s):</span><br><span class="line">...     digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line">...     return digits[s]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, map(char2num, &apos;13579&apos;))</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<p>字符串str也是一个序列,我们对上一个栗子稍稍更改配合map(),我们就可以实现str到int的转化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line"></span><br><span class="line">def char2num(s):</span><br><span class="line">    return DIGITS[s]</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</span><br></pre></td></tr></table></figure></p>
<p>在python没有提供int()函数时,我们完全可以自己写一个字符串转化为整数的函数(既然有,我为什么要写…)</p>
<p>下面写几个小栗子:<br>1.把用户输入的用户名变为首字母大写，其他小写的规范格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def normalize(name):</span><br><span class="line">    s=name[0:1].upper()+name[1:].lower()</span><br><span class="line">    return s//没想出来和map/reduce有啥关系</span><br></pre></td></tr></table></figure></p>
<p>2.请编写一个prod()函数，可以接受一个list并利用reduce()求积:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def prod(L):</span><br><span class="line">    return reduce(lambda x,y:x*y,L)</span><br></pre></td></tr></table></figure></p>
<p>3.利用map和reduce编写一个str2float函数,把字符串’123.456’转化成123.456:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from functions import reduce</span><br><span class="line">def str2float(s):</span><br><span class="line">    def char2num(s):</span><br><span class="line">        digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line">        return digits[s]</span><br><span class="line">    L = s.split(&quot;.&quot;,1)</span><br><span class="line">    n1=reduce(lambda x,y:x*10+y,map(char2num,L[0]))</span><br><span class="line">    n2=reduce(lambda x,y:x*0.1+y,map(char2num,L[1][::-1]))</span><br><span class="line">    return n1+0.1*n2</span><br></pre></td></tr></table></figure></p>
<p>——另一种方法——<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def char2num(s):</span><br><span class="line">    digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9,&apos;.&apos;:0.0&#125;</span><br><span class="line">    return digits[s]</span><br><span class="line">L1,L2=[],[]</span><br><span class="line">l=list(map(char2num,s))</span><br><span class="line">for x in l:</span><br><span class="line">    if x==0.0:</span><br><span class="line">        break</span><br><span class="line">    L1.append(x)</span><br><span class="line">for y in l[::-1]:</span><br><span class="line">    if y == 0.0:</span><br><span class="line">        break</span><br><span class="line">    L2.append(y)</span><br><span class="line">a=reduce(lambda x,y:x*10+y,L1)</span><br><span class="line">b=reduce(lambda x,y:x*0.1+y,L2)</span><br><span class="line">return a+b*0.1</span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>python内建的filter()函数用于过滤序列.</p>
<p>和map()类似,filter(function,iterable)也接受一个函数和一个序列,和map()不同的是filter()把传入的函数依次作用每个元素,然后根据返回的是True还是False觉决定保留还是丢弃.<br>//filter是一种迭代器:function是布尔型函数,iterable是可迭代对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br></pre></td></tr></table></figure></p>
<p>可见filter()是用来筛选的,返回的是一个Iterator,所以需要list()函数获得所有结果并返回list.<br>一个比较有意思的例子:求素数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0//注意这个lambda中的x是序列的值</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter() # 初始序列</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it) # 返回序列的第一个数</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it) # 构造新序列</span><br><span class="line">for n in primes():</span><br><span class="line">    if n &lt; 1000:</span><br><span class="line">        print(n)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p>
<p>这波代码很有意思,大致是这个意思,首先生成从2开始的自然数,然后去第一个2,把2的倍数删掉,然后再取第一个3,把3的倍数删掉,依次进行,不断筛下去,就可以得到所有的素数…</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>python的排序算法使用内置的sorted()函数就可以对list排序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure></p>
<p>除此之外sorted()函数也是一个高阶函数,它可以接受一个key函数来实现自定义的排序.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure></p>
<p>key指定的函数作用在list的每一个元素上,并根据key函数返回值的结果进行排序.</p>
<p>现在我们提出排序字母忽略大小写,要实现这个算法其实这些字符串都变为大写(或小写),再比较.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)</span><br><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure></p>
<p>要进行反向,不用改key函数,可以直接传入第三个参数reserve=True:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure></p>
<p>——-小练习——–<br><code>L = [(&#39;Bob&#39;, 75), (&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Lisa&#39;, 88)]</code><br>请用sorted()对上述列表按名字排序,和成绩排序<br><code>`</code><br>def by_name(t):</p>
<pre><code>return t[0].lower()//名字排序
</code></pre><hr>
<p>def by_name(t):<br>    return -t[1]//按成绩从大到小,使用符号来相反输出</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/forth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/forth/" itemprop="url">小圆第四天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T14:59:09+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>在函数内部,我们可以调用其他函数,也可以调用函数自身,这样的函数我们叫递归函数.举个栗子我们求n!:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1 or n==0:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br><span class="line">------调试如下------</span><br><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure></p>
<p>递归的优点是定义简单,思路清晰,但是每调用一层栈会加一层栈帧,栈不是无限大的,所以会溢出,fact(1000)就会报错…<br>那么我们怎么解决呢,看到廖大大的教程说是改成尾递归,就可以把递归优化,乌罗调用多少次,就只占用一个栈帧,具体就是return语句不能包含表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    return fact_iter(n, 1)</span><br><span class="line"></span><br><span class="line">def fact_iter(num, product):</span><br><span class="line">    if num == 1:</span><br><span class="line">        return product</span><br><span class="line">    return fact_iter(num - 1, num * product)</span><br></pre></td></tr></table></figure></p>
<p>这里的num-1和num*product在函数调用前就会被计算,不影响函数调用.遗憾的是大多数变成语言没有对尾递归做优化,python解释器也没有,所以依然会栈溢出.对于递归函数的经典示例为递归函数,和c语言类似,这里不再阐述.</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><p>首先明白python的高级特性有什么用?通过之前的学习已经可以编写出很多有用的程序了,而使用高级特性可以简写代码,1行能写出来为什么要写2行..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">n = 1</span><br><span class="line">while n &lt;= 99:</span><br><span class="line">    L.append(n)</span><br><span class="line">    n = n + 2</span><br><span class="line">------比较笨的办法------</span><br><span class="line">M = list(range(1,100,2))</span><br><span class="line">print(&apos;M=&apos;,M)</span><br><span class="line">------这个挺好的------</span><br><span class="line">M = [i for i in range(1,100) if i%2!=0]</span><br><span class="line">print(M)</span><br></pre></td></tr></table></figure></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取list或tuple的部分元素首先想到怎么取?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]//取前n个怎么办?</span><br><span class="line">------笨的办法------</span><br><span class="line">&gt;&gt;&gt; r = []</span><br><span class="line">&gt;&gt;&gt; n = 3</span><br><span class="line">&gt;&gt;&gt; for i in range(n):</span><br><span class="line">...     r.append(L[i])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p>
<p>每次都要写循环太麻烦了吧,python提供了切片操作符,能够让这个麻烦的事情变简单.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p>
<p>L[0:3]表示,从索引0开始,直到索引3为止但是不包括3,正好3个元素,如果第一个元素是0还可以省略:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]//和上面的一样</span><br><span class="line">&gt;&gt;&gt; L[1:3]//从索引1开始取出两个元素:</span><br><span class="line">&gt;&gt;&gt; L[-2:]//取后两个</span><br><span class="line">&gt;&gt;&gt; L[-2:-1//取倒数第二个</span><br><span class="line">&gt;&gt;&gt; L = list(range(100))</span><br><span class="line">&gt;&gt;&gt; L[:10]//取前十个</span><br><span class="line">&gt;&gt;&gt; L[-10:]//取后十个</span><br><span class="line">&gt;&gt;&gt; L[10:20]//前10-20个</span><br><span class="line">&gt;&gt;&gt; L[:10:2]//前10个,每两个取一个</span><br></pre></td></tr></table></figure></p>
<p>tuple也一样,但是切过之后操作结果仍然是tuple,字符串’xxx’也可以看做list,所以也可以切片,且过之后还是字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure></p>
<p>一个例子实现trim()函数,取出字符串首尾的空格(str的strip函数可以取出字符串的指定字符):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def trim(s):</span><br><span class="line">    while s and s[0]==&apos; &apos;:</span><br><span class="line">        s=s[1:]</span><br><span class="line">    while s and s[-1]==&apos; &apos;:</span><br><span class="line">        s=s[:-1]</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个list或者tuple,我们可以通过循环来遍历list或者tuple,我们称这种遍历为迭代,在python里只要是可以迭代的对象都可以使用for循环,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p>
<p>因为dict不是和list一样按照list方式顺序排序,所以可能迭代出的顺序不一样.默认情况下dict迭代出的是key,如果要迭代出value可以用<font color="red">for value in d.values()</font>，如果要同时迭代key和value，可以用<font color="red">for k, v in d.items()</font>.<br>字符串也是可以迭代的对象,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for ch in &apos;ABC&apos;:</span><br><span class="line">...     print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<p>说了这么多到底什么是可迭代,什么是不可以迭代的呢,这里python提供了一个Iterable来判断,这个函数在collections模块里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>最后一个小问题,c语言是通过下标循环,python可不可以呢?当然可以,python内提供了enumerate函数,可以把list变成索引-元素对,这应就可以在for里迭代出索引和元素了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure></p>
<h2 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h2><p>列表生成器是python内置的非常简单却强大的创建list的生成器,举个栗子:生成1-10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">------那么如果要生成1X1,2X2,3X3...,10X10------</span><br><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br></pre></td></tr></table></figure></p>
<p>上面你可能也发现很繁琐,现在所学习的高级特性就是解决繁琐问题,而列表生成器可以简化:<br><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]</code><br>写列表生成器时,把要生成的元素放到前面,后面跟for循环,就可以创建出来.我们也可以有如下用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]//for循环后面加上判断,可以做筛选</span><br><span class="line">------也可以生成全排列------</span><br><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure></p>
<p>列表生成器也可以使用两个变量来生成list:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br></pre></td></tr></table></figure></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式,我们可以方便的创建一个list,但是我们的内存是有限的,列表的容量不能太大,如果我们创建的列表很大,但是只需要访问前几个元素,那后面的空间就浪费了,所以生成器就是可以按照某种算法推算出来后面生成的元素,而不必创建完整的list,在Python中，这种一边循环一边计算的机制，称为生成器：generator.</p>
<h3 id="第一种创建生成器的方法"><a href="#第一种创建生成器的方法" class="headerlink" title="第一种创建生成器的方法"></a>第一种创建生成器的方法</h3><p>第一种方法很简单,只要把列表生成器的[]改成()就可以了.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g//这里的g是一个generator</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure></p>
<p>generator不能够直接打印,我们可以通过next()来获得generator的返回值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">......</span><br><span class="line">//超出时会报错</span><br></pre></td></tr></table></figure></p>
<p>上面的方法一遍一遍的调用太麻烦了,因为generator是一个可迭代的对象,所以我们可以用循环来打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure></p>
<h3 id="第二种方法创建生成器"><a href="#第二种方法创建生成器" class="headerlink" title="第二种方法创建生成器"></a>第二种方法创建生成器</h3><p>著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到,斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b//相当于一个tuple赋值给a,b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure></p>
<p>我们仔细看就可以发现,fib函数其实就是定义了推算规则,也就是说和generator很像,我们只需要把print(b)改为<font color="red">yield b</font>就可以变成生成器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure></p>
<p>这就是第二种定义的方法,注意generator与函数的执行流程不同,<font color="red">generator在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行</font>.举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&apos;step 1&apos;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&apos;step 2&apos;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&apos;step 3&apos;)</span><br><span class="line">    yield(5)</span><br><span class="line">------调用如下------</span><br><span class="line">&gt;&gt;&gt; o = odd()</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>回到fib的例子,同样把函数改为generator后我们可以用迭代来打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in fib(6):</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>聪明的你肯定发现我们没有打印’done’也就是没有执行return语句(我当初怎么没有发现…),如果我们想要拿到返回值需要捕获StopIteration错误,返回值在StopIteration的Value中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = fib(6)</span><br><span class="line">&gt;&gt;&gt; while True://这块以后再详细介绍</span><br><span class="line">...     try:</span><br><span class="line">...         x = next(g)</span><br><span class="line">...         print(&apos;g:&apos;, x)</span><br><span class="line">...     except StopIteration as e:</span><br><span class="line">...         print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">...         break</span><br><span class="line">...</span><br><span class="line">g: 1</span><br><span class="line">g: 1</span><br><span class="line">g: 2</span><br><span class="line">g: 3</span><br><span class="line">g: 5</span><br><span class="line">g: 8</span><br><span class="line">Generator return value: done</span><br></pre></td></tr></table></figure></p>
<p>做一下小练习:<font color="red">杨辉三角</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def triangles():</span><br><span class="line">    L=[0,1,0]</span><br><span class="line">    while True:</span><br><span class="line">        yield L[1:-1]</span><br><span class="line">        L=[L[i]+L[i+1] for i in range(len(L)-1)]</span><br><span class="line">        L=[0]+L+[0]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def triangles():</span><br><span class="line">    L=[1]</span><br><span class="line">    while True:</span><br><span class="line">        yield L</span><br><span class="line">        L=L+[0]</span><br><span class="line">        L=[(L[i-1]+L[i]) for i in range(len(L))]</span><br></pre></td></tr></table></figure>
<p>这道题折腾好久,以后要多看看</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道可以直接for循环的有以下几种:<br>一类是集合数据类型如:list,tuple,dict,set,str<br>一类是generator,包括生成器和带yield的generator functions 这些可以直接用于for循环的对象统称为可迭代对象:Iterable(可用isintance()判断)<br>而生成器不仅可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到StopIteration错误表示无法继续返回下一个值了.<br>可以被<font color="red">next()</font>哈数调用并不断返回下一个值的对象称为:<font color="red">Iterator</font>(可用isinstance()判断):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>生成器都是Iterator对象,要把Iterable变成Iterator可以使用<font color="red">iter()</font>函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<hr>
<p>小结一下:<br>凡是可作用于for循环的对象都是Iterable类型</p>
<p>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/third/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/third/" itemprop="url">小圆第三天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T21:53:02+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>python内置了很多有用的函数,可以方面我们直接调用,我们只需要知道函数的名称和参数就能使用,而不用在意具体实现.例如下面几个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>当我们不知道函数怎么使用时可以通过help(函数名)的方法查看帮助文档如: help(abs)<br>同时python也可以进行数据类型的转换(注意bool类型转换时数值0和空字符串表示false)如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&apos;1.23&apos;</span><br><span class="line">&gt;&gt;&gt; str(100)</span><br><span class="line">&apos;100&apos;</span><br><span class="line">&gt;&gt;&gt; bool(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&apos;&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,等于说给函数起了一个小名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在python中定义一个函数要使用def语句,依次写出函数名,括号,括号中的参数和冒号,然后在缩进中写函数体:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure></p>
<p>顺便提下,如果写一个函数保存在py文件里,在这个文件目录下进入命令行模式通过 from 文件名(不含.py) import 函数名,可以将这个函数导入进来.import以后详细说明<br>将自己写的函数my_abs与内置函数abs传入一个非法参数例如’A’,比较错误信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br><span class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &apos;str&apos;</span><br></pre></td></tr></table></figure></p>
<p>可以发现内置的abs函数会检查出参数错误,而我们自己写的却没有,我们如何给自己的函数添加参数检查呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure></p>
<p>数据类型检查可以用内置函数isinstance()实现,检查出错误可以通过raise来将错误抛出 ,错误和异常以后再说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure></p>
<p>有时我们会让函数返回多个值,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure></p>
<p>import math语句表示导入math包,并允许使用包里的sin,cos等函数,让我们来看返回值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure></p>
<p>这样就返回了两个值,并赋给x,y,但其实这是一个假象,这个函数的返回值其实是一个tuple:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(r)</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python的函数定义非常简单,但是灵活度却非常大,除了正常的必选参数以外,还有默认参数,可变参数,和关键字参数.</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>例如我们想让一个函数可以计算x的n次方,但默认不给参数n的情况下,我们默认计算x的平方.示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure></p>
<p>这样我们调用power(5)与调用power(5,2)是一样的,而对于n&gt;2的情况就必须明确的传入参数n.<br>使用默认参数需要注意:</p>
<p><font color="red" size="4">1.已选参数需要放到默认参数前面<br>2.设置默认参数时,把变化大的参数放到前面,变化小的参数放到后面,变化小的就可以作为默认参数</font><br>举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender):</span><br><span class="line">    print(&apos;name:&apos;, name)</span><br><span class="line">    print(&apos;gender:&apos;, gender)</span><br></pre></td></tr></table></figure></p>
<p>我们学生注册信息时需要传入name,gender两个参数,但让我们继续传入年龄,城市信息怎么办?我们可以吧年龄和城市设为默认参数(因为在一个学校入学年龄基本不变,大多也来自同一个城市):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=6, city=&apos;Beijing&apos;):</span><br><span class="line">    print(&apos;name:&apos;, name)</span><br><span class="line">    print(&apos;gender:&apos;, gender)</span><br><span class="line">    print(&apos;age:&apos;, age)</span><br><span class="line">    print(&apos;city:&apos;, city)</span><br></pre></td></tr></table></figure></p>
<p>这样大多数就注册时就不需要提供年龄和城市,只需要提供必要的两个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&apos;Sarah&apos;, &apos;F&apos;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br><span class="line">----------------------</span><br><span class="line">enroll(&apos;Bob&apos;, &apos;M&apos;, 7)</span><br><span class="line">enroll(&apos;Adam&apos;, &apos;M&apos;, city=&apos;Tianjin&apos;)</span><br></pre></td></tr></table></figure></p>
<p>有多个默认参数时,既可以按顺序提供默认参数,比如enroll(‘Bob’, ‘M’, 7),最后的城市使用默认值,也可以不按照顺序,但是需要把参数名字写上如:enroll(‘Adam’, ‘M’, city=’Tianjin’),city参数用传入的值,其他用默认值.</p>
<p><font color="red" size="4">1.接下来会有一个默认参数的坑需要特别注意,默认参数不能使用可变对象</font>示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure></p>
<p>解释如下:<br>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。<br>修改上面的例子,我们可以用<font color="red">不变对象</font>来实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure></p>
<p>这样不论调用多少次都不会有问题.</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个<br>要计算a^2 + b^2 + c^2 + …,定义这个函数由于参数不确定,我们首先想到将a,b,c作为一个list或tuple传进来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>但是这样的话,我们调用需要先组装一个list或tuple:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure></p>
<p>如果利用可变参数,就会简单很多,使用在参数前面加上星号,这样函数接受到的就是一个<font color="red">tuple</font>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>直接使用calc(1,2),calc()就可以实现函数调用,但是如果我们有一个list或者tuple要传入函数怎么办?python已经为我们准备好啦!我们在传参的时候在list或者tuple变量名字前面加上星号就可以将它里面的所有元素变成可变参数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure></p>
<p>函数person除了必选参数外还有关键字参数,可以只传必选参数,也可以传入任意个关键字参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么关键字有啥用?这个可以扩展函数的功能,比如注册信息时,有必选像和可选项,可以利用关键字参数满足用户需求,和可变参数类似,也可以将一个dict转化为关键字参数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>**extra表示把extra这个dict的所有key-value用关键字参数传到**kw里面</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数,不能够保证我传入的数据一定合法,所以就有了命名关键字参数,和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符<em>,</em>后面的参数视为关键字参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">-----调用如下------</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)//调用时参数名一定要写,否则报错</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>如果函数定义中有一个可变参数(<em>args),因为他也有\</em>,所以后面跟着命名的关键字参数就不再需要加*了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)//但是后面的参数一定都要是命名关键字参数</span><br></pre></td></tr></table></figure></p>
<p>实际上命名关键字有时候可以缺省,使用默认值来实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">------调用如下-----</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>注意使用命名关键字时,如果没有可变参数,一定要加*.</p>
<h3 id="参数组合搞一波"><a href="#参数组合搞一波" class="headerlink" title="参数组合搞一波"></a>参数组合搞一波</h3><p>在python中定义函数有必选参数,默认参数,可变参数,关键字参数,命名关键字参数,但参数定义的顺序必须是<font color="red">必选参数,默认参数,可变参数,命名关键字参数,关键字参数</font>示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br><span class="line">----调用如下----</span><br><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一个神奇的东西,通过tuple或dit,也可以调用上面的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以聪明的你看懂了吗?</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">贾燎原</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾燎原</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
