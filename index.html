<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="燎原的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="燎原的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="燎原的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>燎原的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">燎原的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/seventh/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/seventh/" itemprop="url">小圆第七天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T21:08:20+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>————-模块的好处————-</p>
<p>最大的好处是大大提高了代码的可维护性,使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中,但是也要注意，尽量不要与内置函数名字冲突.</p>
<p>你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package).</p>
<p>假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mycompany</span><br><span class="line">├─ \_\_init\_\_.py</span><br><span class="line">├─ abc.py</span><br><span class="line">└─ xyz.py</span><br></pre></td></tr></table></figure></p>
<p>现在，<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>，类似的，<code>xyz.py</code>的模块名变成了<code>mycompany.xyz</code>。</p>
<p>请注意，每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是mycompany。</p>
<p>—————-小结一下————-</p>
<p>1、每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p>
<p>2、init.py可以是空文件，也可以有Python代码，因为init.py本身就是一个模块；</p>
<p>3、模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</p>
<p>4、模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</p>
<p>5、内置函数解释地址：<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a></p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python本身内置很多有用的模块,可以直接使用eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3  #注释,加上后可以直接在Unix/Linux/Mac上运行</span><br><span class="line"># -*- coding: utf-8 -*- #注释,表示.py本身使用标准UTF-8编码</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;  #任何模块代码的第一个字符串都被视为文档注释;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;  #作者姓名..</span><br><span class="line"></span><br><span class="line">import sys  #导入模块</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv  #模块内的argv变量,用list存储命令行的所有参数,至少有一个元素(该.py文件的名称)</span><br><span class="line">    #例如:运行python3 hello.py jialiaoyuan获得的sys.argv就是[&apos;hello.py&apos;,&apos;jialiaoyuan&apos;].</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&apos;Hello, world!&apos;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&apos;Hello, %s!&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test() #如果在其他地方导入这个模块,if判断失败,不执行test(),用来测试使用</span><br></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>和类c语言类似,有时候我们不想让一些变量或函数暴露出来,所以可以添加私有变量,在python中通过<code>_</code>前缀来实现.</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途,类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用,之所以说”不应该”是应为Python编辑器<font color="red">拦不住</font>你想访问,我们在编程习惯上不应该引用private函数或变量.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def _private_1(name):</span><br><span class="line">    return &apos;Hello, %s&apos; % name</span><br><span class="line"></span><br><span class="line">def _private_2(name):</span><br><span class="line">    return &apos;Hi, %s&apos; % name</span><br><span class="line"></span><br><span class="line">def greeting(name):</span><br><span class="line">    if len(name) &gt; 3:</span><br><span class="line">        return _private_1(name)</span><br><span class="line">    else:</span><br><span class="line">        return _private_2(name)</span><br></pre></td></tr></table></figure></p>
<p>通过这种方法,我们公开<code>greeting()</code>函数,而内部的private函数隐藏,这样就不用关注细节,只用来提供接口就可以.</p>
<h1 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h1><p>面向对象编程—-Object Oriented Programming,简称OOP,OOP把对象作为程序的基本单元.一个对象包含了数据和操作数据的函数.</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>接下来copy了一个非常有意思的评论,加深理解类.<br>上帝</p>
<p>class 类 (人)<br>instance 实例 (你,我,他)<br>你会有些属性(身高,年龄,体重)<br>你会有些技能(吃饭,泡妞)</p>
<p><code>__init__</code> 方法的主要作用,就是初始化你的属性,这些属性,在上帝初始化你的时候就要赋予给你,比如<code>zhangsan = Person(170,29,50)`</code>这时上帝就把你创造出来了，也就是实例化了你，然后，你到底有哪些技能呢，这就看有没有在类里面定义了，如果有定义泡妞的技能，那么你就可以调用泡妞的技能来泡妞，大致就是这样吧，看看下面的例子就更清楚了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"># 这里就是初始化你将要创建的实例的属性</span><br><span class="line">    def __init__(self,hight,weight,age):</span><br><span class="line">        self.hight = hight</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"># 定义你将要创建的实例所有用的技能</span><br><span class="line">    def paoniu(self):</span><br><span class="line">        print(&apos;你拥有泡妞的技能&apos;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;you can eat&apos;)</span><br><span class="line"></span><br><span class="line"># 开始创建实例</span><br><span class="line">zhangsan=Person(170,50,29)</span><br><span class="line">lisi = Person(175,100,30)</span><br><span class="line"></span><br><span class="line"># 你的实例开始使用它的技能</span><br><span class="line">zhangsan.paoniu()</span><br><span class="line">lisi.eat()</span><br></pre></td></tr></table></figure></p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象中最重要的就是类和实例,类是抽象的模板,而实例是根据类创建出来的一个个具体的”对象”.让我们先定义一个空类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>class后面紧跟的是类名,即Student,类名通常开头字母大写,紧接着是<code>(object)</code>,表示该类是从哪继承的,也可以不写,默认继承<code>object</code>类,这是所有的类最终都会继承的类.创建实例是通过类名+()实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>bart</code>指向的是<code>Student</code>的实例,后面跟着内存地址,而Student本身则是一个类.</p>
<p>可以自由的给给一个变量绑定属性,比如给<code>bart</code>绑定了一个<code>name</code>属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.name = &apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以在创建实例的时候,把必须绑定的属性强制添进去,通过<code>__init__</code>方法就可以把<code>name</code>,<code>score</code>等属性绑上去.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure></p>
<p>注意<code>__init__</code>第一个参数永远是<code>self</code>,表示实例本身,如果类中有了<code>__init__</code>,在创建实例的时候,就不能传入空的参数,<font color="red">必须</font>传入与<code>__init__</code>方法匹配的参数,但是<code>self</code>实例本身不需要传.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure></p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>面对对象编程的一个重要的特点就是数据封装.在上面的<code>Student</code>类中,每个实例都有name,score这些数据,我们可以通过函数访问这些数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_score(std):</span><br><span class="line">...     print(&apos;%s: %s&apos; % (std.name, std.score))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_score(bart)</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure></p>
<p>但是,既然Student实例本身都有这些数据,那么我们为什么要在外边定义函数访问呢?我们可以在内部定义这些函数,谁调用我们自己处理就好了,这就把数据’封装’起来了,我们称之为类的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.name, self.score))</span><br><span class="line">    #调用如下</span><br><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure></p>
<p>我们还可以给Student类添加新的方法,比如<code>get_grade</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;= 90:</span><br><span class="line">            return &apos;A&apos;</span><br><span class="line">        elif self.score &gt;= 60:</span><br><span class="line">            return &apos;B&apos;</span><br><span class="line">        else:</span><br><span class="line">            return &apos;C&apos;</span><br><span class="line">    #调用如下</span><br><span class="line">&gt;&gt;&gt;bart.get_grade()</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>前面刚刚介绍了类和对象可以隐藏内部的复杂逻辑.但是之前好像又说到可以自由的修改一个实例的<code>name</code>,<code>score</code>属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; bart.score = 99</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure></p>
<p>如果想让内部属性不能呗外部访问,可以把属性名称前面加上两个<code>__</code>,这样就变成了私有变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.__name, self.__score))</span><br><span class="line">        #改完后测试一波</span><br><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;__name&apos;</span><br></pre></td></tr></table></figure></p>
<p>但是如果我们还想访问和改变怎么办?</p>
<p>这时候我们就可以给类增加<code>get_score</code>和<code>get_name</code>以及<code>set_score</code>这样的方法,通过内部的方法来访问,返回内部的值.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&apos;bad score&apos;)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是: 在python中类似<code>__xxx__</code>这样的变量名是特殊变量,可以直接访问,所以不能用<code>__name__</code>,<code>__score__</code>这样的变量名.</p>
<p>有时候你会看到一个下划线开头的变量名比如<code>_name</code>这样的变量是可以从外部访问的,但是按照约定,你看到这样的变量就是说”我虽然可以访问,但是,请你把我看做私有变量”</p>
<p>那么双下划线一定不能访问吗?</p>
<p>其实也不是.不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<p>但是强烈不建议你这么做,因为不同的python为把<code>__name</code>改成不同的名字,总的来说python本身不阻止你做坏事,一切靠自觉.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.get_name()</span><br><span class="line">&apos;Bart Simpson&apos;</span><br><span class="line">&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">&apos;New Name&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面这种写法表面是’成功’的设置了<code>__name</code>变量,但实际上这个<code>__name</code>变量和class内部的<code>__name__</code>不是一个变量!这时外部仅仅给<code>bart</code>增加了一个新的<code>__name</code>变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</span><br><span class="line">&apos;Bart Simpson&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><p>在OPP程序设计中,当我们定义一个class的时候,可以从现在有的class,新的class称为子类,被继承的class称为基类,父类,或者超类.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#首先写一个父类</span><br><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Animal is running...&apos;)</span><br><span class="line">#再写两个子类</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>对于<code>Dog</code>来说,<code>Animmal</code>是它的父类,对于<code>Animal</code>来说,<code>Dog</code>就是它的子类.</p>
<p>那么继承有啥好处?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br><span class="line">#结果如下:</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure></p>
<p>可以看到子类获得父类的全部功能,<code>Dog</code>和<code>Cat</code>什么都没做就自动拥有了<code>run()</code>.</p>
<p>当然我们也可以对子类添加一些方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Dog is running...&apos;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;Eating meat...&apos;)</span><br><span class="line">#再次运行</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line">Dog is running..</span><br></pre></td></tr></table></figure></p>
<p>当子类和父类存在相同的方法时比如<code>run()</code>,子类的<code>run()</code>覆盖父类的<code>run()</code>,所以总是调用子类的<code>run()</code>,这样我们就获得了继承的另一个好处:<font color="red">多态</font></p>
<p>要理解多态,我们要先明白当我们定义一个class时就是定义一个数据类型,和str,list,dict没什么区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = list() # a是list类型</span><br><span class="line">b = Animal() # b是Animal类型</span><br><span class="line">c = Dog() # c是Dog类型</span><br><span class="line">&gt;&gt;&gt; isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Dog)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>最后一个例子可以看出c不仅仅是<code>Dog</code>,c还是<code>Animal</code>!,但是反过来就不可以!</p>
<p>要理解多态的好处还是要通过示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br><span class="line">#这时我们传入Animal的实例:</span><br><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br><span class="line">#传入Dog的实例:</span><br><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure></p>
<p>看上去好像没啥意思,但是我们再定义一个<code>Tortoise</code>类型,也从<code>Animal</code>派生:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Tortoise is running slowly...&apos;)</span><br><span class="line">#实现调用:</span><br><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure></p>
<p>你会发现多态的好处就是当我们传入<code>Dog</code>,<code>Cat</code>,<code>Tortoise</code>….时,我们只需要接受<code>Animal</code>类型就可以了,因为它们都是<code>Animal</code>类型,按照<code>Animal</code>类型操作就可以了,这就是多态的意思,调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则</p>
<h3 id="静态语言VS动态语言"><a href="#静态语言VS动态语言" class="headerlink" title="静态语言VS动态语言"></a>静态语言VS动态语言</h3><p>对于静态语言(java,c++),如果需要传入<code>Animal</code>类型,则传入的对象必须是<code>Animal</code>类型或者它的子类,否则不能调用<code>run()</code>,而对于Python这样的动态语言,只需要保证传入的对象有一个<code>run()</code>方法就可以了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Start...&apos;)</span><br><span class="line">#对它进行调用</span><br><span class="line">&gt;&gt;&gt; run_twice(Timer())</span><br><span class="line">Start...</span><br><span class="line">Start...</span><br></pre></td></tr></table></figure></p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象.</p>
<p>也可以这么说:python不限制参数类型，那任何对象都可以传入，只要它有需要调用的方法，代码都可以顺利运行。另一方面，即使传入的对象继承了理想中的对象，也不能保证该对象还具有需要调用的方法，因为我甚至可以在对象里把从父类继承的方法变成None,所以一切靠自觉遵守规则.</p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>当我们拿到一个对应的引用时,我们如何才能知道对象是什么类型,有哪些方法呢?</p>
<h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><p>首先,我们来判断对象的类型,使用<code>type()</code>函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(&apos;str&apos;)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(None)</span><br><span class="line">&lt;type(None) &apos;NoneType&apos;&gt;</span><br><span class="line">#如果一个变量指向一个函数或者类:</span><br><span class="line">&gt;&gt;&gt; type(abs)</span><br><span class="line">&lt;class &apos;builtin_function_or_method&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;__main__.Animal&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>type()函数返回的是对应的class类型,我们可以加上if判断来比较两个变量的type是否相同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123)==type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123)==int</span><br><span class="line">True</span><br><span class="line">#如果要判断一个对象是否是函数,可以使用tpyes模块中定义的常量:</span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)==types.LambdaType #使用FunctionType也可以</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说<code>type()</code>就显得不是很方便,所以就有了<code>isinstance()</code>函数.<br><code>#假设继承关系:object -&gt; Animal -&gt; Dog -&gt; Husky</code><br>那么可以用<code>isinstance()</code>来判断对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Animal()</span><br><span class="line">&gt;&gt;&gt; d = Dog()</span><br><span class="line">&gt;&gt;&gt; h = Husky()</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Husky)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><code>h</code>虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型,也就是说<code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上.<br>能用<code>type()</code>判断的基本类型也可以用<code>isinstan()</code>判断,并且可以判断一个变量是否是某些变量的一种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(b&apos;a&apos;, bytes)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p><font color="red">总是优先使用<code>isinstance()</code>判断类型,可以将制定类型及其子类”一网打尽”</font></p>
<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>如果要获得一个对象的所有属性和方法,可以使用<code>dir()</code>函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure></p>
<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<code>__len__</code>()方法，所以，下面的代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;len(&apos;abc&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt;&apos;abc&apos;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>仅仅知道对象的属性和方法是不够的,我们配合<code>getattr()</code>(获取属性),<code>setattr()</code>(设置属性),以及<code>hasattr()</code>(判断属性),我们可以直接操作一个对象的状态.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#首先让我们先定义一个类:</span><br><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         return self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br><span class="line">#然后我们测试属性</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &apos;y&apos;) # 有属性&apos;y&apos;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&apos;y&apos;</span><br><span class="line">19</span><br></pre></td></tr></table></figure></p>
<p>如果试图获取不存在的属性,会抛出AttributeError的错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;) # 获取属性&apos;z&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;MyObject&apos; object has no attribute &apos;z&apos;</span><br><span class="line">#可以传入一个default参数,如果属性不存在就返回默认值:</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &apos;z&apos;, 404) # 获取属性&apos;z&apos;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure></p>
<p>———–小结一下————</p>
<p>只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：<code>sum = obj.x + obj.y</code>,就不要使用<code>getattr</code><br>以上获取对象信息我们什么时候会用到呢?<br>下面代码<font color="red">很重要</font>.多思考…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 首先你有一个command.py文件，内容如下，这里我们假若它后面还有100个方法</span><br><span class="line"></span><br><span class="line">class MyObject(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 9</span><br><span class="line">    def add(self):</span><br><span class="line">        return self.x + self.x</span><br><span class="line"></span><br><span class="line">    def pow(self):</span><br><span class="line">        return self.x * self.x</span><br><span class="line"></span><br><span class="line">    def sub(self):</span><br><span class="line">        return self.x - self.x</span><br><span class="line"></span><br><span class="line">    def div(self):</span><br><span class="line">        return self.x / self.x</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 然后我们有一个入口文件 exec.py，要根据用户的输入来执行后端的操作</span><br><span class="line">from command import MyObject</span><br><span class="line">computer=MyObject()</span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    inp = input(&apos;method&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    if inp == &apos;add&apos;:</span><br><span class="line">        computer.add()</span><br><span class="line">    elif inp == &apos;sub&apos;:</span><br><span class="line">        computer.sub()</span><br><span class="line">    elif inp == &apos;div&apos;:</span><br><span class="line">        computer.div()</span><br><span class="line">    elif inp == &apos;pow&apos;:</span><br><span class="line">        computer.pow()</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;404&apos;)</span><br></pre></td></tr></table></figure>
<p>上面使用了if来判断,如果真有100个那么我们总不能写100次判断吧!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from command import MyObject</span><br><span class="line"></span><br><span class="line">computer=MyObject()</span><br><span class="line">def run(x):</span><br><span class="line">    inp = input(&apos;method&gt;&apos;)</span><br><span class="line">    # 判断是否有这个属性</span><br><span class="line">    if hasattr(computer,inp):</span><br><span class="line">    # 有就获取然后赋值给新的变量</span><br><span class="line">        func = getattr(computer,inp)</span><br><span class="line">        print(func())</span><br><span class="line">    else:</span><br><span class="line">    # 没有我们来set一个</span><br><span class="line">        setattr(computer,inp,lambda x:x+1)</span><br><span class="line">        func = getattr(computer,inp)</span><br><span class="line">        print(func(x))</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    run(10)</span><br></pre></td></tr></table></figure></p>
<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>之前我们就已经知道给一个实例绑定属性的方法是通过实例变量,或者通过<code>self</code>变量,但是如果<code>Student</code>类本身需要绑定一个属性呢?可以直接在class中定义属性,这种属性是类属性,归<code>Student</code>所有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;#虽然归类所有,但是类的所有实例都可以访问</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p>
<p>———–小练习—————-</p>
<p>为了统计学生人数,每增加一个类属性,每创建一个实例,该属性自动增加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    count = 0</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count+=1</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/sixth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/sixth/" itemprop="url">小圆第六天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-19T17:43:38+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的.<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<hr>
<p>小结一下:<br>面向对象：一个有诸多技能的工人，可以让这个工人去干很多事情</p>
<p>函数式编程：一群只有单个技能的工人，可以让他们同时出动去干一件复杂的事情</p>
<p>高阶函数：一个工人必须依靠下一个工人的技能才能完成工作</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>告诫函数除了可以接受函数作为参数外,还可以将函数作为结果返回.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>当我们调用lazy_sum()时返回的并不是结果,而是一个函数,当我们不需要立即求和,而是根据需要再来计算,就可以使用这种方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中,外部函数定义了内部函数sum,当外部函数返回sum时,相关参数和变量都保存在返回的函数中,这种结构我们称为闭包.请注意当我们调用lazy_sum()时,每次都会返回一个新的函数,即使传入一个新的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f1==f2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>我们还需要注意另一个问题,返回的函数没有立刻执行,而是直到调用f()才执行.栗子如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure></p>
<p>#你可能认为调用f1(),f2(),f3()的结果应该是1,4,9,那么实际上呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>全部都是9!因为返回的函数使用了变量i,但上边也说过返回的函数不是立刻执行,等到3个函数都返回时,它所引用的i已经变为3,所以最后都是9.<br><code>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</code></p>
<p>如果一定要引用循环怎么办?不怕,我们可以在创建一个函数,让这个函数的参数来绑定循环变量,无论循环变量怎么改,绑定到函数参数的值不变:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure></p>
<p>——–让我们再看看其他关于闭包的解释——-<br>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#闭包函数的实例</span><br><span class="line"># outer是外部函数 a和b都是外函数的临时变量</span><br><span class="line">def outer( a ):</span><br><span class="line">    b = 10</span><br><span class="line">    # inner是内函数</span><br><span class="line">    def inner():</span><br><span class="line">        #在内函数中 用到了外函数的临时变量</span><br><span class="line">        print(a+b)</span><br><span class="line">    # 外函数的返回值是内函数的引用</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 在这里我们调用外函数传入参数5</span><br><span class="line">    #此时外函数两个临时变量 a是5 b是10 ，并创建了内函数，然后把内函数的引用返回存给了demo</span><br><span class="line">    # 外函数结束的时候发现内部函数将会用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数</span><br><span class="line">    demo = outer(5)</span><br><span class="line">    # 我们调用内部函数，看一看内部函数是不是能使用外部函数的临时变量</span><br><span class="line">    # demo存了外函数的返回值，也就是inner函数的引用，这里相当于执行inner函数</span><br><span class="line">    demo() # 15</span><br><span class="line"></span><br><span class="line">    demo2 = outer(7)</span><br><span class="line">    demo2()#17</span><br></pre></td></tr></table></figure></p>
<p>在基本的python语法中,一个函数可以随意读取全局数据,但是要修改的时候有两种方法:<font color="red">:1 global 声明全局变量 2 全局变量是可变类型数据的时候可以修改.</font>:<br>1 在python3中，可以用nonlocal 关键字声明 一个变量， 表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量。</p>
<p>　　　　2 在python2中，没有nonlocal这个关键字，我们可以把闭包变量改成可变类型数据进行修改，比如列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#修改闭包变量的实例</span><br><span class="line"># outer是外部函数 a和b都是外函数的临时变量</span><br><span class="line">def outer( a ):</span><br><span class="line">    b = 10  # a和b都是闭包变量</span><br><span class="line">    c = [a] #这里对应修改闭包变量的方法2</span><br><span class="line">    # inner是内函数</span><br><span class="line">    def inner():</span><br><span class="line">        #内函数中想修改闭包变量</span><br><span class="line">        # 方法1 nonlocal关键字声明,也可以使用global方法,内层和外层都要声明</span><br><span class="line">        nonlocal  b</span><br><span class="line">        b+=1</span><br><span class="line">        # 方法二，把闭包变量修改成可变数据类型 比如列表</span><br><span class="line">        c[0] += 1</span><br><span class="line">        print(c[0])</span><br><span class="line">        print(b)</span><br><span class="line">    # 外函数的返回值是内函数的引用</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"></span><br><span class="line">    demo = outer(5)</span><br><span class="line">    demo() # 6  11</span><br></pre></td></tr></table></figure></p>
<p>还有一点要注意:使用闭包的过程中,一旦外函数被调用了一次返回了内函数的引用,虽然每次调用内函数,是开启一个函数执行过后消亡,但是闭包变量实际只有一份,每次开启内函数都是在使用同一份闭包变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf8</span><br><span class="line">def outer(x):</span><br><span class="line">    def inner(y):</span><br><span class="line">        nonlocal x</span><br><span class="line">        x+=y</span><br><span class="line">        return x</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = outer(10)</span><br><span class="line">print(a(1)) #11</span><br><span class="line">print(a(3)) #14</span><br></pre></td></tr></table></figure></p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>之前没有看这章教程的时候就百度过匿名函数的用法,这次终于找到机会把它补全:</p>
<p>匿名函数存在的意义:当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">----lambda x: x*x相当于----</span><br><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure></p>
<p>关键字<font color="red">lambda</font>表示匿名函数,冒号前面的x表示函数参数.</p>
<p>匿名函数有一定的限制,就是只能有一个表达式,返回值就是表达式的结果.但也有优点:不必担心函数名冲突,匿名函数是一个变量,也可以赋值给另一个变量,再利用该变量调用函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>函数对象有一个<strong>name</strong>属性,可以拿到函数的名字:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     print(&apos;2018-11-19&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = now</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">2015-3-25</span><br><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;now&apos;</span><br><span class="line">&gt;&gt;&gt; f.__name__</span><br><span class="line">&apos;now&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在,我们想让now()函数不仅仅打印现在的时间,而是想加一点功能,但是又不希望改变now()函数的定义,在这种代码运行期间动态增加功能的方式我们称为<font color="red">装饰器</font>.</p>
<p>本质上,decorator是一个<font color="red">返回函数</font>的高阶函数,我们可以如下定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-11-19&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面的log函数接受一个函数做参数,返回一个函数.然后通过@语法,把decorator置于函数的定义处,让我们来看结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">2018-11-19</span><br></pre></td></tr></table></figure></p>
<p>把<font color="red">@log</font>放到<font color="red">now()</font>函数的定义处相当于执行了语句:<code>now = log(now)</code>由于log()是一个decorator,返回一个函数,所以原来的<font color="red">now()</font>仍然存在,只是现在同名的now()指向了新的函数,条用新函数,即在<font color="red">log()</font>函数中返回的wrapper()函数.</p>
<p><font color="red">wrapper()</font>函数的参数定义是<font color="red">(*args,**kw)</font>,因此,<font color="red">wrapper()</font>函数可以接受任意参数的调用.</p>
<p>如果decorator本身要传入参数,那么我们需要写一个返回decorator的高阶函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2018-11-19&apos;)</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">execute now():</span><br><span class="line">2018-11-19</span><br></pre></td></tr></table></figure></p>
<p>和两套嵌套相比,三层嵌套本质是这样<code>&gt;&gt;&gt; now = log(&#39;execute&#39;)(now)</code></p>
<p>以上两种decorator的定义都没有问题，但还差最后一步.使用<strong>name</strong>来查看now函数的名称发现它不再是now,而是变成了wrapper:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;wrapper&apos;</span><br></pre></td></tr></table></figure></p>
<p>因为返回的那个<font color="red">wrapper()</font>函数的名字就是<font color="red">‘wrapper’</font>,所以我们需要把原始的<strong>name</strong>等属性赋值到<font color="red">wrapper</font>函数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure></p>
<p>这样now().<strong>name</strong>就变成now了,置于import functools是导入模块,以后再讲,现在就是在<font color="red">wrapper()</font>函数上加入<font color="red">@functools.wraps(func)</font>就可以了.</p>
<p>—接下来做一个小练习—</p>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import time, functools</span><br><span class="line">def metric(fn):</span><br><span class="line">    @functools.wraps(fn)</span><br><span class="line">    def costtime(*args,**kw):</span><br><span class="line">        start=time.time()</span><br><span class="line">        s=fn(*args,**kw)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(&apos;%s executed in %s ms&apos; % (fn.__name__, end-start))</span><br><span class="line">        return s</span><br><span class="line">    return costtime</span><br><span class="line"># 测试</span><br><span class="line">@metric</span><br><span class="line">def fast(x, y):</span><br><span class="line">    time.sleep(0.0012)</span><br><span class="line">    return x + y;</span><br></pre></td></tr></table></figure></p>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>Python的functools模块提供很多有用的功能,其中一个就是偏函数,在介绍函数参数的时候我们讲到,通过设定函数的默认值可以降低调用的难度,巧了,偏函数也可以.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;)</span><br><span class="line">12345 #默认把字符串转化为整数(10进制)</span><br></pre></td></tr></table></figure></p>
<p><font color="red">int()</font>函数还提供额外的base参数,默认值为10.传入其它的可以做N进制转换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;, base=8)</span><br><span class="line">5349</span><br><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;, 16)</span><br><span class="line">74565</span><br></pre></td></tr></table></figure></p>
<p>当我们有大量的二进制字符串需要转换,每次写int(x,base=2)你乐意吗?我肯定不这么写,所以我们之前可以想到定义一个函数,把默认<font color="red">base=2</font>传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def int2(x,base=2):</span><br><span class="line">    return int(x,base)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p>
<p>这样是不是简单多啦!functools就是帮助我们创建一个偏函数,不需要我们自己定义int2():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1010101&apos;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure></p>
<p>所以简答总结,偏函数的作用就是让函数的某些参数固定住,返回一个新函数.</p>
<p>最后,创建一个偏函数的时候可以接受函数对象,*args,**kw这三个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=2)</span><br><span class="line">#实际上固定int()函数的base相当于</span><br><span class="line">kw=&#123;&apos;base&apos;:2&#125;</span><br><span class="line">int(&apos;10010&apos;,**kw)</span><br></pre></td></tr></table></figure></p>
<p>当传入:<code>max2 = functools.partial(max, 10)</code><br>实际上会把10作为*args的一部分自动加到左边,也就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br><span class="line">#相当于</span><br><span class="line">args = (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/fifth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/fifth/" itemprop="url">小圆第五天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T22:39:11+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的.<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<hr>
<p>小结一下:<br>面向对象：一个有诸多技能的工人，可以让这个工人去干很多事情</p>
<p>函数式编程：一群只有单个技能的工人，可以让他们同时出动去干一件复杂的事情</p>
<p>高阶函数：一个工人必须依靠下一个工人的技能才能完成工作</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>变量可以指向函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f(-10)</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>说明变量f现在已经指向了abs所指向的函数,现在调用f()和abs()完全相同</p>
<p>函数名也是变量:</p>
<p>对于abs()这个函数,完全可以把函数看做变量,它指向一个可以计算绝对值的函数!如果把abs指向其他对象,会怎么样?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs = 10</span><br><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;int&apos; object is not callable</span><br></pre></td></tr></table></figure></p>
<p>注:abs函数实际在import builtins模块中,所以要让让abs在其他模块也生效,要用<font color="red">import builtins; builtins.abs = 10</font>.</p>
<p>传入函数:<br>既然变量可以指向函数,函数的参数能接受变量,那么一个函数就可以接受另一个函数作为参数,这种函数就称为高阶函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br><span class="line">------调用如下------</span><br><span class="line">print(add(-5,6,abs))</span><br><span class="line">11</span><br></pre></td></tr></table></figure></p>
<p>在看评论时有一个有意思的东西来记录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max, min = min, max</span><br><span class="line"></span><br><span class="line">print(max(1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure></p>
<p>函数赋值的时候,在赋值之前min,max都已经确定了,这里右边为一个tuple,并不会因为将max值赋为min而改变.</p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>我们先来看map(),map接受两个参数,一个是函数,一个是<font color="red">Iterable</font>,map将传入的函数依次作用到序列的每个元素,并把结果作为新的<font color="red">Iterator</font>返回:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure></p>
<p>因为返回的是Iterator,Iterator是惰性序列,所以要通过list()函数将整个序列都计算出来返回一个list.</p>
<p>你可能会想,不需要map(),我用循环也能写出来…:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:</span><br><span class="line">    L.append(f(n))</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure></p>
<p>确实可以,但是你可能看不出来’把f(x)作用在list的每一个元素并把结果返回一个新的list</p>
<p>所以map()作为告诫函数,事实上把运算规则抽象了,你还可以计算任意复杂的函数,比如转化为字符串,转化为绝对值…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]</span><br><span class="line">-----------------------</span><br><span class="line">&gt;&gt;&gt; list(map(abs,[1,-2,3,4,-5,,6,7,-8,-9]))</span><br><span class="line">[1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></p>
<p>再看看reduce的用法:<br>reduce把一个函数作用在[X1,X2,X3,…]上这个函数必须接收<font color="red">两个</font>参数,reduce把结果继续和序列的下一个元素做积累计算,效果就是:<br><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code><br>举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<p>这个栗子本身没啥意思,但是下面就开始热身了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def char2num(s):</span><br><span class="line">...     digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line">...     return digits[s]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, map(char2num, &apos;13579&apos;))</span><br><span class="line">13579</span><br></pre></td></tr></table></figure></p>
<p>字符串str也是一个序列,我们对上一个栗子稍稍更改配合map(),我们就可以实现str到int的转化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line"></span><br><span class="line">def char2num(s):</span><br><span class="line">    return DIGITS[s]</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</span><br></pre></td></tr></table></figure></p>
<p>在python没有提供int()函数时,我们完全可以自己写一个字符串转化为整数的函数(既然有,我为什么要写…)</p>
<p>下面写几个小栗子:<br>1.把用户输入的用户名变为首字母大写，其他小写的规范格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def normalize(name):</span><br><span class="line">    s=name[0:1].upper()+name[1:].lower()</span><br><span class="line">    return s//没想出来和map/reduce有啥关系</span><br></pre></td></tr></table></figure></p>
<p>2.请编写一个prod()函数，可以接受一个list并利用reduce()求积:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def prod(L):</span><br><span class="line">    return reduce(lambda x,y:x*y,L)</span><br></pre></td></tr></table></figure></p>
<p>3.利用map和reduce编写一个str2float函数,把字符串’123.456’转化成123.456:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from functions import reduce</span><br><span class="line">def str2float(s):</span><br><span class="line">    def char2num(s):</span><br><span class="line">        digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;</span><br><span class="line">        return digits[s]</span><br><span class="line">    L = s.split(&quot;.&quot;,1)</span><br><span class="line">    n1=reduce(lambda x,y:x*10+y,map(char2num,L[0]))</span><br><span class="line">    n2=reduce(lambda x,y:x*0.1+y,map(char2num,L[1][::-1]))</span><br><span class="line">    return n1+0.1*n2</span><br></pre></td></tr></table></figure></p>
<p>——另一种方法——<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def char2num(s):</span><br><span class="line">    digits = &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9,&apos;.&apos;:0.0&#125;</span><br><span class="line">    return digits[s]</span><br><span class="line">L1,L2=[],[]</span><br><span class="line">l=list(map(char2num,s))</span><br><span class="line">for x in l:</span><br><span class="line">    if x==0.0:</span><br><span class="line">        break</span><br><span class="line">    L1.append(x)</span><br><span class="line">for y in l[::-1]:</span><br><span class="line">    if y == 0.0:</span><br><span class="line">        break</span><br><span class="line">    L2.append(y)</span><br><span class="line">a=reduce(lambda x,y:x*10+y,L1)</span><br><span class="line">b=reduce(lambda x,y:x*0.1+y,L2)</span><br><span class="line">return a+b*0.1</span><br></pre></td></tr></table></figure></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>python内建的filter()函数用于过滤序列.</p>
<p>和map()类似,filter(function,iterable)也接受一个函数和一个序列,和map()不同的是filter()把传入的函数依次作用每个元素,然后根据返回的是True还是False觉决定保留还是丢弃.<br>//filter是一种迭代器:function是布尔型函数,iterable是可迭代对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br></pre></td></tr></table></figure></p>
<p>可见filter()是用来筛选的,返回的是一个Iterator,所以需要list()函数获得所有结果并返回list.<br>一个比较有意思的例子:求素数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0//注意这个lambda中的x是序列的值</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter() # 初始序列</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it) # 返回序列的第一个数</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it) # 构造新序列</span><br><span class="line">for n in primes():</span><br><span class="line">    if n &lt; 1000:</span><br><span class="line">        print(n)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p>
<p>这波代码很有意思,大致是这个意思,首先生成从2开始的自然数,然后去第一个2,把2的倍数删掉,然后再取第一个3,把3的倍数删掉,依次进行,不断筛下去,就可以得到所有的素数…</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>python的排序算法使用内置的sorted()函数就可以对list排序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure></p>
<p>除此之外sorted()函数也是一个高阶函数,它可以接受一个key函数来实现自定义的排序.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure></p>
<p>key指定的函数作用在list的每一个元素上,并根据key函数返回值的结果进行排序.</p>
<p>现在我们提出排序字母忽略大小写,要实现这个算法其实这些字符串都变为大写(或小写),再比较.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)</span><br><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure></p>
<p>要进行反向,不用改key函数,可以直接传入第三个参数reserve=True:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure></p>
<p>——-小练习——–<br><code>L = [(&#39;Bob&#39;, 75), (&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Lisa&#39;, 88)]</code><br>请用sorted()对上述列表按名字排序,和成绩排序<br><code>`</code><br>def by_name(t):</p>
<pre><code>return t[0].lower()//名字排序
</code></pre><hr>
<p>def by_name(t):<br>    return -t[1]//按成绩从大到小,使用符号来相反输出</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/forth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/forth/" itemprop="url">小圆第四天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T14:59:09+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>在函数内部,我们可以调用其他函数,也可以调用函数自身,这样的函数我们叫递归函数.举个栗子我们求n!:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1 or n==0:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br><span class="line">------调试如下------</span><br><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure></p>
<p>递归的优点是定义简单,思路清晰,但是每调用一层栈会加一层栈帧,栈不是无限大的,所以会溢出,fact(1000)就会报错…<br>那么我们怎么解决呢,看到廖大大的教程说是改成尾递归,就可以把递归优化,乌罗调用多少次,就只占用一个栈帧,具体就是return语句不能包含表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    return fact_iter(n, 1)</span><br><span class="line"></span><br><span class="line">def fact_iter(num, product):</span><br><span class="line">    if num == 1:</span><br><span class="line">        return product</span><br><span class="line">    return fact_iter(num - 1, num * product)</span><br></pre></td></tr></table></figure></p>
<p>这里的num-1和num*product在函数调用前就会被计算,不影响函数调用.遗憾的是大多数变成语言没有对尾递归做优化,python解释器也没有,所以依然会栈溢出.对于递归函数的经典示例为递归函数,和c语言类似,这里不再阐述.</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><p>首先明白python的高级特性有什么用?通过之前的学习已经可以编写出很多有用的程序了,而使用高级特性可以简写代码,1行能写出来为什么要写2行..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">n = 1</span><br><span class="line">while n &lt;= 99:</span><br><span class="line">    L.append(n)</span><br><span class="line">    n = n + 2</span><br><span class="line">------比较笨的办法------</span><br><span class="line">M = list(range(1,100,2))</span><br><span class="line">print(&apos;M=&apos;,M)</span><br><span class="line">------这个挺好的------</span><br><span class="line">M = [i for i in range(1,100) if i%2!=0]</span><br><span class="line">print(M)</span><br></pre></td></tr></table></figure></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取list或tuple的部分元素首先想到怎么取?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]//取前n个怎么办?</span><br><span class="line">------笨的办法------</span><br><span class="line">&gt;&gt;&gt; r = []</span><br><span class="line">&gt;&gt;&gt; n = 3</span><br><span class="line">&gt;&gt;&gt; for i in range(n):</span><br><span class="line">...     r.append(L[i])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p>
<p>每次都要写循环太麻烦了吧,python提供了切片操作符,能够让这个麻烦的事情变简单.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure></p>
<p>L[0:3]表示,从索引0开始,直到索引3为止但是不包括3,正好3个元素,如果第一个元素是0还可以省略:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]//和上面的一样</span><br><span class="line">&gt;&gt;&gt; L[1:3]//从索引1开始取出两个元素:</span><br><span class="line">&gt;&gt;&gt; L[-2:]//取后两个</span><br><span class="line">&gt;&gt;&gt; L[-2:-1//取倒数第二个</span><br><span class="line">&gt;&gt;&gt; L = list(range(100))</span><br><span class="line">&gt;&gt;&gt; L[:10]//取前十个</span><br><span class="line">&gt;&gt;&gt; L[-10:]//取后十个</span><br><span class="line">&gt;&gt;&gt; L[10:20]//前10-20个</span><br><span class="line">&gt;&gt;&gt; L[:10:2]//前10个,每两个取一个</span><br></pre></td></tr></table></figure></p>
<p>tuple也一样,但是切过之后操作结果仍然是tuple,字符串’xxx’也可以看做list,所以也可以切片,且过之后还是字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure></p>
<p>一个例子实现trim()函数,取出字符串首尾的空格(str的strip函数可以取出字符串的指定字符):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def trim(s):</span><br><span class="line">    while s and s[0]==&apos; &apos;:</span><br><span class="line">        s=s[1:]</span><br><span class="line">    while s and s[-1]==&apos; &apos;:</span><br><span class="line">        s=s[:-1]</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个list或者tuple,我们可以通过循环来遍历list或者tuple,我们称这种遍历为迭代,在python里只要是可以迭代的对象都可以使用for循环,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p>
<p>因为dict不是和list一样按照list方式顺序排序,所以可能迭代出的顺序不一样.默认情况下dict迭代出的是key,如果要迭代出value可以用<font color="red">for value in d.values()</font>，如果要同时迭代key和value，可以用<font color="red">for k, v in d.items()</font>.<br>字符串也是可以迭代的对象,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for ch in &apos;ABC&apos;:</span><br><span class="line">...     print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<p>说了这么多到底什么是可迭代,什么是不可以迭代的呢,这里python提供了一个Iterable来判断,这个函数在collections模块里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>最后一个小问题,c语言是通过下标循环,python可不可以呢?当然可以,python内提供了enumerate函数,可以把list变成索引-元素对,这应就可以在for里迭代出索引和元素了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure></p>
<h2 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h2><p>列表生成器是python内置的非常简单却强大的创建list的生成器,举个栗子:生成1-10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">------那么如果要生成1X1,2X2,3X3...,10X10------</span><br><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br></pre></td></tr></table></figure></p>
<p>上面你可能也发现很繁琐,现在所学习的高级特性就是解决繁琐问题,而列表生成器可以简化:<br><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]</code><br>写列表生成器时,把要生成的元素放到前面,后面跟for循环,就可以创建出来.我们也可以有如下用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]//for循环后面加上判断,可以做筛选</span><br><span class="line">------也可以生成全排列------</span><br><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure></p>
<p>列表生成器也可以使用两个变量来生成list:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br></pre></td></tr></table></figure></p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式,我们可以方便的创建一个list,但是我们的内存是有限的,列表的容量不能太大,如果我们创建的列表很大,但是只需要访问前几个元素,那后面的空间就浪费了,所以生成器就是可以按照某种算法推算出来后面生成的元素,而不必创建完整的list,在Python中，这种一边循环一边计算的机制，称为生成器：generator.</p>
<h3 id="第一种创建生成器的方法"><a href="#第一种创建生成器的方法" class="headerlink" title="第一种创建生成器的方法"></a>第一种创建生成器的方法</h3><p>第一种方法很简单,只要把列表生成器的[]改成()就可以了.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [x * x for x in range(10)]</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g//这里的g是一个generator</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure></p>
<p>generator不能够直接打印,我们可以通过next()来获得generator的返回值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">......</span><br><span class="line">//超出时会报错</span><br></pre></td></tr></table></figure></p>
<p>上面的方法一遍一遍的调用太麻烦了,因为generator是一个可迭代的对象,所以我们可以用循环来打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; for n in g:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure></p>
<h3 id="第二种方法创建生成器"><a href="#第二种方法创建生成器" class="headerlink" title="第二种方法创建生成器"></a>第二种方法创建生成器</h3><p>著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到,斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b//相当于一个tuple赋值给a,b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure></p>
<p>我们仔细看就可以发现,fib函数其实就是定义了推算规则,也就是说和generator很像,我们只需要把print(b)改为<font color="red">yield b</font>就可以变成生成器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure></p>
<p>这就是第二种定义的方法,注意generator与函数的执行流程不同,<font color="red">generator在每次调用next()的时候执行,遇到yield语句返回,再次执行时从上次返回的yield语句处继续执行</font>.举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&apos;step 1&apos;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&apos;step 2&apos;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&apos;step 3&apos;)</span><br><span class="line">    yield(5)</span><br><span class="line">------调用如下------</span><br><span class="line">&gt;&gt;&gt; o = odd()</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">step 3</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>回到fib的例子,同样把函数改为generator后我们可以用迭代来打印:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in fib(6):</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>聪明的你肯定发现我们没有打印’done’也就是没有执行return语句(我当初怎么没有发现…),如果我们想要拿到返回值需要捕获StopIteration错误,返回值在StopIteration的Value中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = fib(6)</span><br><span class="line">&gt;&gt;&gt; while True://这块以后再详细介绍</span><br><span class="line">...     try:</span><br><span class="line">...         x = next(g)</span><br><span class="line">...         print(&apos;g:&apos;, x)</span><br><span class="line">...     except StopIteration as e:</span><br><span class="line">...         print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">...         break</span><br><span class="line">...</span><br><span class="line">g: 1</span><br><span class="line">g: 1</span><br><span class="line">g: 2</span><br><span class="line">g: 3</span><br><span class="line">g: 5</span><br><span class="line">g: 8</span><br><span class="line">Generator return value: done</span><br></pre></td></tr></table></figure></p>
<p>做一下小练习:<font color="red">杨辉三角</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def triangles():</span><br><span class="line">    L=[0,1,0]</span><br><span class="line">    while True:</span><br><span class="line">        yield L[1:-1]</span><br><span class="line">        L=[L[i]+L[i+1] for i in range(len(L)-1)]</span><br><span class="line">        L=[0]+L+[0]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def triangles():</span><br><span class="line">    L=[1]</span><br><span class="line">    while True:</span><br><span class="line">        yield L</span><br><span class="line">        L=L+[0]</span><br><span class="line">        L=[(L[i-1]+L[i]) for i in range(len(L))]</span><br></pre></td></tr></table></figure>
<p>这道题折腾好久,以后要多看看</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>我们已经知道可以直接for循环的有以下几种:<br>一类是集合数据类型如:list,tuple,dict,set,str<br>一类是generator,包括生成器和带yield的generator functions 这些可以直接用于for循环的对象统称为可迭代对象:Iterable(可用isintance()判断)<br>而生成器不仅可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到StopIteration错误表示无法继续返回下一个值了.<br>可以被<font color="red">next()</font>哈数调用并不断返回下一个值的对象称为:<font color="red">Iterator</font>(可用isinstance()判断):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>生成器都是Iterator对象,要把Iterable变成Iterator可以使用<font color="red">iter()</font>函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<hr>
<p>小结一下:<br>凡是可作用于for循环的对象都是Iterable类型</p>
<p>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列</p>
<p>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>
<p>Python的for循环本质上就是通过不断调用next()函数实现的.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/third/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/third/" itemprop="url">小圆第三天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-16T21:53:02+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>python内置了很多有用的函数,可以方面我们直接调用,我们只需要知道函数的名称和参数就能使用,而不用在意具体实现.例如下面几个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>当我们不知道函数怎么使用时可以通过help(函数名)的方法查看帮助文档如: help(abs)<br>同时python也可以进行数据类型的转换(注意bool类型转换时数值0和空字符串表示false)如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&apos;1.23&apos;</span><br><span class="line">&gt;&gt;&gt; str(100)</span><br><span class="line">&apos;100&apos;</span><br><span class="line">&gt;&gt;&gt; bool(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&apos;&apos;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>函数名其实就是指向一个函数对象的引用,完全可以把函数名赋给一个变量,等于说给函数起了一个小名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>在python中定义一个函数要使用def语句,依次写出函数名,括号,括号中的参数和冒号,然后在缩进中写函数体:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure></p>
<p>顺便提下,如果写一个函数保存在py文件里,在这个文件目录下进入命令行模式通过 from 文件名(不含.py) import 函数名,可以将这个函数导入进来.import以后详细说明<br>将自己写的函数my_abs与内置函数abs传入一个非法参数例如’A’,比较错误信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br><span class="line">&gt;&gt;&gt; abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &apos;str&apos;</span><br></pre></td></tr></table></figure></p>
<p>可以发现内置的abs函数会检查出参数错误,而我们自己写的却没有,我们如何给自己的函数添加参数检查呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure></p>
<p>数据类型检查可以用内置函数isinstance()实现,检查出错误可以通过raise来将错误抛出 ,错误和异常以后再说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&apos;A&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure></p>
<p>有时我们会让函数返回多个值,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure></p>
<p>import math语句表示导入math包,并允许使用包里的sin,cos等函数,让我们来看返回值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure></p>
<p>这样就返回了两个值,并赋给x,y,但其实这是一个假象,这个函数的返回值其实是一个tuple:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(r)</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python的函数定义非常简单,但是灵活度却非常大,除了正常的必选参数以外,还有默认参数,可变参数,和关键字参数.</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>例如我们想让一个函数可以计算x的n次方,但默认不给参数n的情况下,我们默认计算x的平方.示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure></p>
<p>这样我们调用power(5)与调用power(5,2)是一样的,而对于n&gt;2的情况就必须明确的传入参数n.<br>使用默认参数需要注意:</p>
<p><font color="red" size="4">1.已选参数需要放到默认参数前面<br>2.设置默认参数时,把变化大的参数放到前面,变化小的参数放到后面,变化小的就可以作为默认参数</font><br>举个栗子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender):</span><br><span class="line">    print(&apos;name:&apos;, name)</span><br><span class="line">    print(&apos;gender:&apos;, gender)</span><br></pre></td></tr></table></figure></p>
<p>我们学生注册信息时需要传入name,gender两个参数,但让我们继续传入年龄,城市信息怎么办?我们可以吧年龄和城市设为默认参数(因为在一个学校入学年龄基本不变,大多也来自同一个城市):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age=6, city=&apos;Beijing&apos;):</span><br><span class="line">    print(&apos;name:&apos;, name)</span><br><span class="line">    print(&apos;gender:&apos;, gender)</span><br><span class="line">    print(&apos;age:&apos;, age)</span><br><span class="line">    print(&apos;city:&apos;, city)</span><br></pre></td></tr></table></figure></p>
<p>这样大多数就注册时就不需要提供年龄和城市,只需要提供必要的两个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; enroll(&apos;Sarah&apos;, &apos;F&apos;)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: 6</span><br><span class="line">city: Beijing</span><br><span class="line">----------------------</span><br><span class="line">enroll(&apos;Bob&apos;, &apos;M&apos;, 7)</span><br><span class="line">enroll(&apos;Adam&apos;, &apos;M&apos;, city=&apos;Tianjin&apos;)</span><br></pre></td></tr></table></figure></p>
<p>有多个默认参数时,既可以按顺序提供默认参数,比如enroll(‘Bob’, ‘M’, 7),最后的城市使用默认值,也可以不按照顺序,但是需要把参数名字写上如:enroll(‘Adam’, ‘M’, city=’Tianjin’),city参数用传入的值,其他用默认值.</p>
<p><font color="red" size="4">1.接下来会有一个默认参数的坑需要特别注意,默认参数不能使用可变对象</font>示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=[]):</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure></p>
<p>解释如下:<br>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。<br>修改上面的例子,我们可以用<font color="red">不变对象</font>来实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L=None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(&apos;END&apos;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure></p>
<p>这样不论调用多少次都不会有问题.</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个<br>要计算a^2 + b^2 + c^2 + …,定义这个函数由于参数不确定,我们首先想到将a,b,c作为一个list或tuple传进来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>但是这样的话,我们调用需要先组装一个list或tuple:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc([1, 2, 3])</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; calc((1, 3, 5, 7))</span><br><span class="line">84</span><br></pre></td></tr></table></figure></p>
<p>如果利用可变参数,就会简单很多,使用在参数前面加上星号,这样函数接受到的就是一个<font color="red">tuple</font>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure></p>
<p>直接使用calc(1,2),calc()就可以实现函数调用,但是如果我们有一个list或者tuple要传入函数怎么办?python已经为我们准备好啦!我们在传参的时候在list或者tuple变量名字前面加上星号就可以将它里面的所有元素变成可变参数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个dict:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br></pre></td></tr></table></figure></p>
<p>函数person除了必选参数外还有关键字参数,可以只传必选参数,也可以传入任意个关键字参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么关键字有啥用?这个可以扩展函数的功能,比如注册信息时,有必选像和可选项,可以利用关键字参数满足用户需求,和可变参数类似,也可以将一个dict转化为关键字参数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>**extra表示把extra这个dict的所有key-value用关键字参数传到**kw里面</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数,不能够保证我传入的数据一定合法,所以就有了命名关键字参数,和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符<em>,</em>后面的参数视为关键字参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">-----调用如下------</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=&apos;Beijing&apos;, job=&apos;Engineer&apos;)//调用时参数名一定要写,否则报错</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>如果函数定义中有一个可变参数(<em>args),因为他也有\</em>,所以后面跟着命名的关键字参数就不再需要加*了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)//但是后面的参数一定都要是命名关键字参数</span><br></pre></td></tr></table></figure></p>
<p>实际上命名关键字有时候可以缺省,使用默认值来实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">------调用如下-----</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure></p>
<p>注意使用命名关键字时,如果没有可变参数,一定要加*.</p>
<h3 id="参数组合搞一波"><a href="#参数组合搞一波" class="headerlink" title="参数组合搞一波"></a>参数组合搞一波</h3><p>在python中定义函数有必选参数,默认参数,可变参数,关键字参数,命名关键字参数,但参数定义的顺序必须是<font color="red">必选参数,默认参数,可变参数,命名关键字参数,关键字参数</font>示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br><span class="line">----调用如下----</span><br><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一个神奇的东西,通过tuple或dit,也可以调用上面的函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以聪明的你看懂了吗?</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/second/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/second/" itemprop="url">小圆第二天的学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T15:04:48+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python之第二天学习笔记"><a href="#python之第二天学习笔记" class="headerlink" title="python之第二天学习笔记"></a>python之第二天学习笔记</h1><h2 id="list列表与tuple元组"><a href="#list列表与tuple元组" class="headerlink" title="list列表与tuple元组"></a>list列表与tuple元组</h2><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><p>list是一种有序的集合,可以随时添加和删除其中的元素,用以下示例来说明list用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; classmates[0]</span><br><span class="line">&apos;Michael&apos;</span><br><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">&apos;Tracy&apos;</span><br></pre></td></tr></table></figure></p>
<p>list类似于c中的数组,但是使用起来比数组要方便,list列表是用[]来表示,至于为什么要强调这个因为下面还有个tuple使用()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&apos;Adam&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates.pop(1)</span><br><span class="line">&apos;Jack&apos;</span><br></pre></td></tr></table></figure></p>
<p>添加一个元素,删除一个元素可以指定位置,注意insert必须指定插入位置,而append默认添加到最后一个.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; L = [&apos;Apple&apos;, 123, True]</span><br></pre></td></tr></table></figure></p>
<p>如果要替换list中的某个元素可以直接赋值,list内部的元素可以是不同的数据类型.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; p = [&apos;asp&apos;, &apos;php&apos;]</span><br><span class="line">&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, p, &apos;scheme&apos;]</span><br></pre></td></tr></table></figure></p>
<p>list可以嵌套list,但是嵌套进去的list只能算作1个长度,要访问嵌套list中的某一元素可以将整个list视为一个二维数组如:要访问’php’可以使用s[2][1]来访问</p>
<h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h3><p>其实tuple元组和list列表非常类似,list类表的内容时可变的,而tuple一旦初始化就不能修改,tuple使用()来表示,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure></p>
<p>注意如果元组只有一个元素,要在后面加上’,’,因为()也可以表示小括号,为了消除歧义,后面加上逗号.<br>下面让我们看一个有意思的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &apos;Y&apos;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure></p>
<p>之前说过tuple元组的内容一旦初始化就不能更改,但是为什么这里能更改呢?原因很简单,tuple不能更改它的指向,t[0]仍然指向’a’,t[1]仍然指向’b’,t[2]仍然指向list,但是list所指向的内容可以更改,因此,这个tuple看似也更改了.</p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断,这时候就需要用到条件语句.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure></p>
<p>其实python的判断和c差不多,要注意好<font color="#dd0000">缩进</font><br>缩进,以及不要忘记写<font color="#dd0000">冒号</font><br>.<br>if 判断条件可以简写,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure></p>
<p>只要x是非零数值,非空字符串,非空list就判断为True</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>python的for循环和c语言类似:for…in循环依次把list或tuple中的每个元素迭代出来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br><span class="line">---------------------</span><br><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure></p>
<p>所以for x in …循环就是把每个元素带入变量x,然后执行缩进块的语句.在通过下面这个例子进行思考:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure></p>
<p>如果要求不是1-10相加,而是1-1000相加我们难道要一个一个写吗?当然不是,python提供了range()函数,可以生产一个整数数列,再通过list()函数转化为list.如range(5)生成从0开始到小于5的整数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>
<p>再加一个小练习:请利用循环依次对list中的每个名字打印出’Hello, xxx!’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [&apos;Bart&apos;, &apos;Lisa&apos;, &apos;Adam&apos;]</span><br><span class="line">for i in L:</span><br><span class="line">    print(&apos;Hello,&apos;,i+&apos;!&apos;)</span><br></pre></td></tr></table></figure></p>
<p>这里有必要特别思考一下加上’!’如何消除空格</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>python中的while循环和c语言类似,但要主意好缩进,示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 2</span><br><span class="line">print(sum)</span><br><span class="line">---------------</span><br><span class="line">2500</span><br></pre></td></tr></table></figure></p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在循环中break可以提前退出循环,和c语言一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = 1</span><br><span class="line">while n &lt;= 100:</span><br><span class="line">    if n &gt; 10: # 当n = 11时，条件满足，执行break语句</span><br><span class="line">        break # break语句会结束当前循环</span><br><span class="line">    print(n)</span><br><span class="line">    n = n + 1</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure></p>
<p>执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环中continue可以跳过当前这次循环,和c语言一样,示例如下,输出 1 3 5 7 9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">while n &lt; 10:</span><br><span class="line">    n = n + 1</span><br><span class="line">    if n % 2 == 0: # 如果n是偶数，执行continue语句</span><br><span class="line">        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure></p>
<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>python内置了字典,在其他语言中称为map,使用键-值存储,查找速度快?<br>举个栗子:假设要根据同学的姓名查找成绩,如果用list实现需要两个list,先在名字list中找到姓名,再从成绩list中取出相应的成绩.list越长,耗时越长.如果用dict实现,只需要根据名字查成绩就行,因为它的原理和查字典一样,先在字典的索引表里查到这个字对应的页码,然后翻到这页找到这个字,这种方法速度快,不会随着字典大小的增加而变慢.而list则是从字典的第一页,一页一页的查找.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure></p>
<p>dict是以空间换取时间,把数据放入dict除了初始化还可以通过key值放入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;]</span><br><span class="line">67</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;] = 90</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;] = 88</span><br><span class="line">&gt;&gt;&gt; d[&apos;Jack&apos;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure></p>
<p>由于一个key对应一个value,所以后面的赋值会把前面的冲掉<br>如果key不存在dict就会报错,可以通过in和get的方法判断key是否存在:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;)//返回None,交互环境不显示</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)//人为设置不存在时返回-1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<p>要删除一个key可以用pop(key),连同value也一并删除:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&apos;Bob&apos;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;Michael&apos;: 95, &apos;Tracy&apos;: 85&#125;</span><br></pre></td></tr></table></figure></p>
<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似,只不过不存储value,key值也不能重复,也不是有序的,重复元素在set中自动被过滤,因此set可以看成数学意义上的无序和无重复元素的集合,因此也可以做交集,并集等操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure></p>
<p>set可以通过add(key)方法添加元素到set中,通过remove(key)方法删除元素:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)//dict加入的话直接写</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.remove(4)//dict删除的话使用pop()</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样set同样不能放入不可变对象,否则会报错.</p>
<h3 id="再议不可变对象"><a href="#再议不可变对象" class="headerlink" title="再议不可变对象"></a>再议不可变对象</h3><p>通过上面的讲解list是可变对象,而整数和字符串是不可变对象,对于可变对象list的内部内容时会变化的比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<p>而对于不可变对象,字符串有课replace()方法可以’改变’:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; b = a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&apos;Abc&apos;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure></p>
<p>当我们调用a.replace(‘a’,’A’)时,实际上replace是作用在对象’abc’上的,但是这个方法却没有改变字符串’abc’的内容,而是replace方法创建一个新的字符串’Abc’并返回,如果我们用变量b指向这个字符串,就容易理解了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/first/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/first/" itemprop="url">小圆第一天学习python笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T15:04:32+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python之第一天学习笔记"><a href="#python之第一天学习笔记" class="headerlink" title="python之第一天学习笔记"></a>python之第一天学习笔记</h1><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>&gt;&gt;&gt; print(&#39;hello, world&#39;)</code><br>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure></p>
<p><font color="#00ffff"> print()会一次打印每个字符串,遇到”,”会输出一个空格. </font></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>python提供了input(),可以让用户输入字符串,并且存放到一个变量里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">xiaoyuan</span><br></pre></td></tr></table></figure></p>
<p>input()可以让你显示一个字符串来提示用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)//input返回值为字符串类型</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure></p>
<p>打印please enter your name:,然后将输入的内容赋值给name</p>
<hr>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>python的注释是#,其他每一行都是一个语句,当语句以冒号:结尾时,缩进的语句视为代码块.按照规定,应该始终坚持使用4个空格的缩进(缩进是python的灵魂)</p>
<h3 id="在python中能够处理-整数-浮点数-字符串-布尔值"><a href="#在python中能够处理-整数-浮点数-字符串-布尔值" class="headerlink" title="在python中能够处理:整数,浮点数,字符串,布尔值"></a>在python中能够处理:整数,浮点数,字符串,布尔值</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>由于计算机使用二进制,所以有时候用十六进制表示比较方便,如0xff00.</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数也就是小数,需要注意的是,对于很大或很小的浮点数，就必须用科学计数法表示,用e来代替10,1.23*10^9就是1.23e9.特别注意,整数和浮点数在计算机内部存储的方式是不同的,整数运算永远是精确的(出发难道也是精确的?是的!),二浮点数运算则可能会有四舍五入的误差.<br>解释一下整数的除法为什么也是精确的:<br>在python中有两种除法/:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure></p>
<p>/除法的计算结果是浮点数,即使两个整数恰好整除,结果也是浮点数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure></p>
<p>还有一种除法是地板除,两个整数的除法仍然是整数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>在python中整数和浮点数没有大小限制(浮点数超出一定范围就直接表示为inf(无限大))</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号’或双引号”括起来的任意文本,如’abc’,”xyz”等,如果’本身也是一个字符,那就可以用””括起来,比如”I’m ok”,如果字符串内部既包含’又包含”怎么办?可以用转义字符\来表示,比如:’i\’m \”ok\”!’表示i’m “ok”其他的看如下示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m ok.&apos;)</span><br><span class="line">I&apos;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m learning\nPython.&apos;)</span><br><span class="line">I&apos;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&apos;\\\n\\&apos;)</span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure></p>
<p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></p>
<p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure></p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>一个布尔值只有True,False两种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 &gt; 2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 5</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>布尔值可以用and,or,not运算<br>空值:None,这个None不能理解为0,因为0是有意义的,而None就是一个特殊的空值<br>python的不安两本十类型不固定,称之为动态语言,与之相对的静态语言就是必须指定变量类型<br>常量:常量就是不能变的量,在python中通常用全部大写的变量名表示常量:<br>PI = 3.14159265359</p>
<h2 id="python中的字符串"><a href="#python中的字符串" class="headerlink" title="python中的字符串"></a>python中的字符串</h2><p>在python3中字符串是以Unicode编码的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;包含中文的str&apos;)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure></p>
<p>ord()函数获取字符的整数表示,chr()函数把编码转化为对应的字符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure></p>
<p>由于python的字符串类型是str,如果在网络上传输,或者保存到磁盘上就需要把str变为以字节为单位的bytes.<br>Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b’ABC’</p>
<p><font color="#00ffff"> 注意’ABC’和b’ABC’不同,虽然后者内容显示和前者一样,但bytes的每个字符都之战一个字节 </font><br>以Unicode表示的str通过encode()方法可以编码为制定的bytes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure></p>
<p>有中文的str不能用ASCII编码,因为超出了编码范围.因此报错,在bytes中无法显示为ASCII的字节用\x##显示<br>反之,我们想要把bytes变为str需要decode():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果bytes中包含无法解码的字节,decode()方法会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure></p>
<p>但如果只有一小部分无效的字节,我们可以通过errors=’ignore’忽略错误的字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">&apos;中&apos;</span><br></pre></td></tr></table></figure></p>
<p>len()函数可以计算str中含有多少个字符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>在python中,采用的格式化方式和C语言是一致的,用%实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure></p>
<p><font color="#00ffff"> 注意:如果字符串里%是一个普通字符? 我们可以用%%来表示一个%: </font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;growth rate: %d %%&apos; % 7</span><br><span class="line">&apos;growth rate: 7 %&apos;</span><br></pre></td></tr></table></figure></p>
<p>还有一种格式化方式:使用字符串format()方法,个人感觉比较麻烦,用到的话再说吧…</p>
<hr>
<p>今天就先到这里吧,感觉还有好多没学,声明一下,这些笔记是依据廖雪峰老师的教程写的,所以看过之后有什么不明白的可以去看一下廖雪峰老师的教程^_^</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/test1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/test1/" itemprop="url">test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T14:31:25+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开始学习python"><a href="#开始学习python" class="headerlink" title="开始学习python"></a>开始学习python</h1><p>因为想学习一下爬虫,所以想写一下博客,记录一下学习的过程,也希望与各位python小白共同进步</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T14:23:55+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">贾燎原</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾燎原</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
