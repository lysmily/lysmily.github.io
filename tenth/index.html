<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="IO编程IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。  基本概念：input， output，stream 存在问题：输入和接收速度不匹配 解决方法：同步、异步(回调–好了叫我，轮询—好了没…好了没) 收获新知：编程语言都会把操作系统提供的低级C接口封装起">
<meta property="og:type" content="article">
<meta property="og:title" content="小圆第十天学习python笔记">
<meta property="og:url" content="http://yoursite.com/tenth/index.html">
<meta property="og:site_name" content="燎原的博客">
<meta property="og:description" content="IO编程IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。  基本概念：input， output，stream 存在问题：输入和接收速度不匹配 解决方法：同步、异步(回调–好了叫我，轮询—好了没…好了没) 收获新知：编程语言都会把操作系统提供的低级C接口封装起">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-11-27T13:51:34.721Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小圆第十天学习python笔记">
<meta name="twitter:description" content="IO编程IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。  基本概念：input， output，stream 存在问题：输入和接收速度不匹配 解决方法：同步、异步(回调–好了叫我，轮询—好了没…好了没) 收获新知：编程语言都会把操作系统提供的低级C接口封装起">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tenth/">





  <title>小圆第十天学习python笔记 | 燎原的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">燎原的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/tenth/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="贾燎原">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="燎原的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">小圆第十天学习python笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-27T21:53:14+08:00">
                2018-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h1><p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。</p>
<ol>
<li>基本概念：input， output，stream</li>
<li>存在问题：输入和接收速度不匹配</li>
<li>解决方法：同步、异步(回调–好了叫我，轮询—好了没…好了没)</li>
<li>收获新知：编程语言都会把操作系统提供的低级C接口封装起来方便使用<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2>读写文件时最常见的IO操作,用法和C兼容.<br>因为现代的操作系统不允许普通的程序直接操作磁盘,所以读写文件就是请求操作系统打开一个文件对象,通过操作系统这个接口从文件对象中读取数据,或者写入数据.<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3>要读取一个文件,使用Python内置的<font color="red"><code>open()</code></font>函数.传入文件名和标识符.<br><code>&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)</code><br>标识符’r’表示读,这样我们就成功的打开了一个文件,如果文件不存在<font color="red"><code>open()</code></font>函数会抛出错误信息.</li>
</ol>
<p>如果文件成功打开,调用<font color="red"><code>read()</code></font>方法可以一次读取文件的全部内容.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;Hello, world!&apos;</span><br></pre></td></tr></table></figure></p>
<p>最后一步就是调用<font color="red"><code>close()</code></font>方法关闭文件.文件使用后必须关闭,否则会占用资源,并且同一时间内操作系统打开的文件数量也是有限的:<code>&gt;&gt;&gt; f.close()</code></p>
<p>由于文件读写时都有可能出现<font color="red"><code>IOError</code></font>,一旦出错,后面的<font color="red"><code>f.close()</code></font>就不会调用,所以我们可以使用<font color="red"><code>try ... finally</code></font>来避免这种情况.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></p>
<p>每次这么写我可不干,Python引入了<font color="red"><code>with</code></font>语句来自动帮我们调用<font color="red"><code>close()</code></font>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure></p>
<p>这其实和前面的<font color="red"><code>try ... finally</code></font>一样.</p>
<p>调用<font color="red"><code>read()</code></font>会一次性读取全部内容,如果内容太大,内存就会炸掉,所以保险起见,可以反复调用<font color="red"><code>read(size)</code></font>方法,每次最多读取size个字节的内容,另外调用<font color="red"><code>readline()</code></font>可以每次读取一行内容,调用<font color="red"><code>readlines()</code></font>一次性读取所有内容并按行返回<font color="red"><code>list</code></font>.</p>
<p>如果文件小就用read(),如果不确定就用read(size),如果是配置文件就用readlines()最方便:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip()) # 把末尾的&apos;\n&apos;删掉</span><br></pre></td></tr></table></figure></p>
<h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>前面所有的都是读取文本文件,并且是UTF-8的文本文件,如果要读取二进制文件,比如图片,视频等,用<font color="red"><code>&#39;rb&#39;</code></font>模式打开文件就可以啦:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.jpg&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos; # 十六进制表示的字节</span><br></pre></td></tr></table></figure></p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>尧都区非UTF-8编码的文本文件,需要给<font color="red"><code>open()</code></font>函数传入<font color="red"><code>encoding</code></font>参数,例如读取GBK编码的文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/gbk.txt&apos;, &apos;r&apos;, encoding=&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;测试&apos;</span><br></pre></td></tr></table></figure></p>
<p>有时候编码不规范的文件会遇到<font color="red"><code>UnicodeDecodeError</code></font>,因为文件里掺杂了一下非法编码的字符,这时让<font color="red"><code>open()</code></font>函数接受一个<font color="red"><code>errors</code></font>参数,表示遇到编码错误如何处理,最简单的方法就是直接忽略<br><code>&gt;&gt;&gt; f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件和读文件类似,只是把<font color="red"><code>open()</code></font>函数传入的标识为<font color="red"><code>&#39;w&#39;</code></font>或者<font color="red"><code>&#39;wb&#39;</code></font>标识写文件或者二进制文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;)</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;Hello, world!&apos;)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>注意,写文件的时候操作系统不会立刻把数据写入磁盘,而是先放到内存缓存起来,只有调用<font color="red"><code>close()</code></font>方法时,操作系统才保证把没有写入磁盘的数据全部写入.所以我们还是乖乖的用<font color="red"><code>with</code></font>语句保险..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure></p>
<p>要写入特定的文本文件依然给<font color="red"><code>open()</code></font>函数传入<font color="red"><code>encoding</code></font>参数,将字符串转换成制定编码.</p>
<p>直接写文件的话,如果文件已存在会把之前的文件内容删掉然后再写,那么我们希望增加怎么办?可以传入<font color="red"><code>&#39;a&#39;</code></font>来进行追加.</p>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>很多时候数据读写不一定是文件,也可以在内存中读写,StringIO就是在内存 中读写str.要把str写入StringIO,我们需要先创建一个StringIO,然后像文件一样写入即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.write(&apos; &apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;world!&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>getvalue()</code></font>方法用于获得写入后的str.要读取StringIO,可以使用一个str初始化StringIO,然后像文件一样读取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s = f.readline()</span><br><span class="line">...     if s == &apos;&apos;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure></p>
<h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO只能操作str,如果要操作二进制数据,就需要使用BytesIO.依然先创建一个BytesIO,然后进行读写bytes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line"># 也可以先初始化然后读取</span><br><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="StringIO与BytesIO小结"><a href="#StringIO与BytesIO小结" class="headerlink" title="StringIO与BytesIO小结"></a>StringIO与BytesIO小结</h3><p>比如说,你需要对获取到的数据进行操作,但是你并不想把本地数据写到本地硬盘上,这时候你就可以使用StringIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">from io import BytesIO</span><br><span class="line">def outputstring():</span><br><span class="line">    return &apos;string \nfrom \noutputstring \nfunction&apos;</span><br><span class="line"></span><br><span class="line">s = outputstring()</span><br></pre></td></tr></table></figure></p>
<p>将函数返回的数据在内存中读:<code>sio = StringIO(s)</code>,也可以使用StringIO本身的方法<code>print(sio.getvalue())</code>,也可以使用file-like object的方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = sio.readlines()</span><br><span class="line">for i in s:</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>将函数返回的数据在内存中写:<code>sio = StringIO()</code>,<code>sio.write(s)</code>,也可以使用String本身的方法查看<code>s=sio.getvalue(),print(s)</code></p>
<p>这时,如果你使用file-like object方法查看时,你会发现数据为空.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line">for i in sio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>我们需要修改文件的指针位置,然后就发现内容居然可以打印了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sio = StringIO()</span><br><span class="line">sio.write(s)</span><br><span class="line">sio.seek(0,0)</span><br><span class="line">print(sio.tell())</span><br><span class="line">for i in sio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到两个方法<font color="red"><code>seek()</code></font>和<font color="red"><code>tell()</code></font>:</p>
<p>tell()用来回去当前文件读取指针的位置</p>
<p>seek()用来移动文件读写指针的指定位置,有两个参数,第一个<font color="red"><code>offset</code></font>:偏移量,需要向前或向后的字节数,正为向前,负为向后;第二个<font color="red"><code>whence</code></font>:可选值,默认为0,表示文件开头,1表示相对于当前位置,2表示文件末尾.</p>
<p>注意使用seek时,如果你的打开的文件没有使用<font color="red"><code>&#39;b&#39;</code></font>的方式打开,则offset无法使用负值.</p>
<p>StringIO只能操作str,要操作二进制数据就要用到BytesIO,并且上面的sio不能使用seek从当前位置向前移动,这时我们使用’b’的方式写入数据,就可以向前移动了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bio = BytesIO()</span><br><span class="line">bio.write(s.encode(&apos;utf-8&apos;))</span><br><span class="line">print(bio.getvalue())</span><br><span class="line">bio.seek(-36,1)</span><br><span class="line">print(bio.tell())</span><br><span class="line">for i in bio.readlines():</span><br><span class="line">    print(i.strip())</span><br></pre></td></tr></table></figure></p>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>我们要操作文件,目录,可以在命令行下输入操作系统提供的命令就可以,那么在Python中怎么玩呢?</p>
<p>其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数,Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name</span><br><span class="line">&apos;nt&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果是<font color="red"><code>posix</code></font>说明操作系统是linux,Unix,或是Mac OS X,如果是nt,就是windows系统.我们还可以使用<font color="red"><code>uname()</code></font>函数来获取更详细的系统信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.uname()</span><br><span class="line">posix.uname_result(sysname=&apos;Darwin&apos;, nodename=&apos;MichaelMacPro.local&apos;, release=&apos;14.3.0&apos;, version=&apos;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&apos;, machine=&apos;x86_64&apos;)</span><br></pre></td></tr></table></figure></p>
<p>注意<font color="red"><code>uname()</code></font>函数在windows上不提供,也就是说os模块的某些函数时跟操作系统相关的.</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>操作系统的环境变量保存在<font color="red"><code>os.environ</code></font>这个变量中,可以直接查看<code>os.environ</code>,要获取摸个环境变量的值可以调用<font color="red"><code>os.environ,get(&#39;key&#39;)</code></font>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&apos;PATH&apos;)</span><br><span class="line">&apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&apos;</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;x&apos;, &apos;default&apos;)</span><br><span class="line">&apos;default</span><br></pre></td></tr></table></figure></p>
<h3 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><p>操作文件和目录的函数一部分在<font color="red"><code>os</code></font>模块中,一部分在<font color="red"><code>os.path</code></font>模块中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br></pre></td></tr></table></figure></p>
<p>两个路径合并成一个时,要通过<font color="red"><code>os.path.join()</code></font>函数,而拆分时要通过<font color="red"><code>os.path.split()</code></font>函数,注意,后一部分总是最后级别的目录或者文件名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>os.path.splitext()</code></font>可以直接让你得到文件的扩展名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br></pre></td></tr></table></figure></p>
<p>上面这些合并,拆分路径的函数并不要求目录和文件要真实存在,他们只对字符串进行操作.下面假设有一个<font color="red"><code>test.txt</code></font>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure></p>
<p>复制文件的函数在os模块中不存在!因为操作系统没有提供系统调用,幸运的是<font color="red"><code>shutil</code></font>模块提供了<font color="red"><code>copyfile()</code></font>的函数.</p>
<p>最后看看如何过滤文件.要求列出当前目录下的所有目录,以及所有的<font color="red"><code>.py</code></font>文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#当前文件下所有目录</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br><span class="line">#当前文件下的所有.py文件</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure></p>
<h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p>编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">def mysearch(path,str):</span><br><span class="line">    for x in os.listdir(path):</span><br><span class="line">        _path=os.path.join(path,x)</span><br><span class="line">        if os.path.isdir(_path):</span><br><span class="line">            mysearch(_path,str)</span><br><span class="line">        else:</span><br><span class="line">            if str in x:</span><br><span class="line">                print(_path)</span><br><span class="line">mysearch(&apos;.&apos;,&apos;a&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>在程序运行的过程中,所有的变量都是在内存中,我们定义一个dict:<code>d = dict(name=&#39;Bob&#39;, age=20, score=88)</code>,我们可以随意的修改变量的值,但是程序一旦结束,变量所占用的内存就被操作系统全部收回,如果修改后的变量没有存储到磁盘上,下次还是会被初始化.</p>
<p>我们吧变量从内存变为可存储或传输的过程叫做序列化,序列化后我们就可以把内容写入磁盘或者通过网络传输.返过来,把变量内容从序列化的对象从新读到内存称为反序列化,Python提供了<font color="red"><code>pickle</code></font>,模块来实现序列化.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>pickle.dumps()</code></font>方法吧任意对象序列化成一个<font color="red"><code>bytes</code></font>,然后就可以把这个bytes写入文件或者用另一个方法<font color="red"><code>pickle.dump()</code></font>直接序列化后写入一个file-like object:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>那么反序列化和序列化类似,我们可以先把内容读到一个<font color="red"><code>bytes</code></font>,然后使用<font color="red"><code>pickle.loads()</code></font>方法反序列化出对象,当然也可以使用<font color="red"><code>pickle.load()</code></font>方法直接序列化写入对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式,JSON表示出来就是一个字符串,可以被所有语言读取,也方便存储和传输.</p>
<p>python内置的<font color="red"><code>json</code></font>模块提供了python对象到JSON格式的转换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><code>dumps()</code></font>方法返回一个str,内容就是标准的JSON,类似,<font color="red"><code>dump()</code></font>方法可以直接把JSON写入一个file-like object</p>
<p>JSON的反序列化为Python对象依然使用<font color="red"><code>load()</code></font>或者<font color="red"><code>loads()</code></font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h3><p>Python的<font color="red"><code>dict</code></font>对象可以直接序列化为JSON的’{}’,有时候我们跟喜欢用<font color="red"><code>class</code></font>表示对象,然后序列化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Bob&apos;, 20, 88)</span><br><span class="line">print(json.dumps(s))</span><br></pre></td></tr></table></figure></p>
<p>运行代码,毫不留情的get到一个<font color="red"><code>TypeError</code></font>,原因是Student不是一个可序列化的JSON对象,这时我们看看dumps()的参数列表.</p>
<p>dumps()的参数列表中除了第一个必须的<font color="red"><code>obj</code></font>参数外,还有很多可选参数,这些可选参数就是让我们来定制JSON序列化,因为默认情况下<font color="red"><code>dumps()</code></font>方法不知道如何将Student实例变为一个JSON的’{}’对象.</p>
<p>可选参数<font color="red"><code>default</code></font>就是把任意一个对象变成可序列化的JSON对象,我们需要专门写一个转换函数,再把函数传进去:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age,</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">    #这样student首先被转换函数转化成dict,然后被顺利的序列化为JSON:</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过下次遇到一个<font color="red"><code>teacher</code></font>类的实例,照样不能序列化为JSON,我们可以偷个懒,把任意<font color="red"><code>class</code></font>的实例变为<font color="red"><code>dict</code></font>:<br><code>print(json.dumps(s, default=lambda obj: obj.__dict__))</code></p>
<p>因为通常<font color="red"><code>class</code></font>的实例都有一个<font color="red"><code>__dict__</code></font>属性,它就是一个<font color="red"><code>dict</code></font>除了少数的例外,比如定义了<font color="red"><code>__slots__</code></font>的class</p>
<p>同样的道理我们要把JSON反序列化为一个<font color="red"><code>Student</code></font>对象实例,<font color="red"><code>loads()</code></font>方法首先转换出一个<font color="red"><code>dict</code></font>对象,然后我们传入的<font color="red"><code>object_hook</code></font>函数负责把dict转换为Student实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">#运行结果如下:</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ninth/" rel="next" title="小圆第九天学习python笔记">
                <i class="fa fa-chevron-left"></i> 小圆第九天学习python笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/eleventh/" rel="prev" title="小圆第十一天学习python笔记">
                小圆第十一天学习python笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">贾燎原</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#IO编程"><span class="nav-number">1.</span> <span class="nav-text">IO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写"><span class="nav-number">1.1.</span> <span class="nav-text">文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读文件"><span class="nav-number">1.1.1.</span> <span class="nav-text">读文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制文件"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">二进制文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符编码"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">字符编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写文件"><span class="nav-number">1.1.2.</span> <span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringIO和BytesIO"><span class="nav-number">1.2.</span> <span class="nav-text">StringIO和BytesIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StringIO"><span class="nav-number">1.2.1.</span> <span class="nav-text">StringIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BytesIO"><span class="nav-number">1.2.2.</span> <span class="nav-text">BytesIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringIO与BytesIO小结"><span class="nav-number">1.2.3.</span> <span class="nav-text">StringIO与BytesIO小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作文件和目录"><span class="nav-number">1.3.</span> <span class="nav-text">操作文件和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作文件和目录-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">操作文件和目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小练习"><span class="nav-number">1.3.3.</span> <span class="nav-text">小练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化"><span class="nav-number">1.4.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON"><span class="nav-number">1.4.1.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON进阶"><span class="nav-number">1.4.2.</span> <span class="nav-text">JSON进阶</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾燎原</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
